<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>August&#39;s Box</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yezizp2012.github.io/"/>
  <updated>2017-06-01T07:23:57.000Z</updated>
  <id>https://yezizp2012.github.io/</id>
  
  <author>
    <name>August</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>airbnb面试题汇总</title>
    <link href="https://yezizp2012.github.io/2017/06/01/airbnb%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://yezizp2012.github.io/2017/06/01/airbnb面试题汇总/</id>
    <published>2017-06-01T07:00:07.000Z</published>
    <updated>2017-06-01T07:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间面试了airbnb北京，顺便整理了下网上能搜到的面经，刷了一遍，主要是coding部分。<br><a id="more"></a></p>
<h3 id="Palindrome-Pairs"><a href="#Palindrome-Pairs" class="headerlink" title="Palindrome Pairs"></a>Palindrome Pairs</h3><p>warm up：is_palindrome</p>
<pre><code>bool isPalindrome（string s) {
    int left = 0, right = s.size() - 1;
    while (left &lt; right) {
        if (s[left++] != s[right--]) return false;
    }
    return true;
}
</code></pre><p>给定一个字符串数组，找出所有的字符串对，该字符串对拼接起来是回文字符串（<a href="https://leetcode.com/problems/palindrome-pairs/?tab=Description）" target="_blank" rel="external">https://leetcode.com/problems/palindrome-pairs/?tab=Description）</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;

bool isPalindrome(string word, int left, int right) {
    while (left &lt; right)
        if(word[left++] != word[right--]) return false;
    return true;
}
   vector&lt;vector&lt;int&gt; &gt; palindromePairs(vector&lt;string&gt;&amp; words) {
    unordered_map&lt;string, int&gt; idx;
    set&lt;int&gt; st;
    vector&lt;vector&lt;int&gt; &gt; ans;
    for (int i = 0; i &lt; words.size(); ++i) {
        idx[words[i]] = i;
        st.insert(words[i].length());
    }
    for (int i = 0 ; i &lt; words.size(); ++i) {
        string tmp = words[i];
        int len = tmp.length();
        reverse(tmp.begin(), tmp.end());
        if (idx.count(tmp) &amp;&amp; idx[tmp] != i)
            ans.push_back({i, idx[tmp]});
        auto end = st.find(len);
        for (auto it = st.begin(); it != end; ++it) {
            if (idx.count(tmp.substr(len - *it)) &amp;&amp; isPalindrome(tmp, 0, len - *it - 1))
                ans.push_back({i, idx[tmp.substr(len - *it)]});
            if (idx.count(tmp.substr(0, *it)) &amp;&amp; isPalindrome(tmp, *it, len - 1))
                ans.push_back({idx[tmp.substr(0, *it)], i});
        }
    }
    return ans;
}
int main() {
    vector&lt;string&gt; words = {&quot;bat&quot;, &quot;tab&quot;, &quot;cat&quot;};
    auto ans = palindromePairs(words);
    for (auto pr : ans) {
        cout &lt;&lt; pr[0] &lt;&lt; &quot; &quot;&lt;&lt; pr[1] &lt;&lt;endl;
    }
    return 0;
}
</code></pre><h3 id="Round-numbers"><a href="#Round-numbers" class="headerlink" title="Round numbers"></a>Round numbers</h3><p>When you book on airbnb the total price is:</p>
<p>Total price = base price + service fee + cleaning fee + …</p>
<pre><code>input : array of decimals ~ X
output : array of int ~ Y
</code></pre><p>But they need to satisfy the condition:</p>
<pre><code>sum(Y) = round(sum(x))
minmize (|y1-x1| + |y2-x2| + ... + |yn-xn|)
Example1:
input = 30.3, 2.4, 3.5
output = 30 2 4

Example2:
input = 30.9, 2.4, 3.9
output = 31 2 4
</code></pre><p>先将所有floor(x)加起来统计出如果所有都floor的话还差多少，按照ceil以后需要加的价格排序，贪心取最小的补齐即可。代码如下：</p>
<pre><code># python
def roundNum(self, input):
    output = map(lambda x: floor(x), input)
    remain = int(round(sum(input)) - sum(output))
    it = sorted(enumerate(input), key=lambda x: x[1] - floor(x[1]))
    for _ in xrange(remain):
        output[it.pop()[0]] += 1
    return output

//c++
vector&lt;int&gt; roundNumber(vector&lt;double&gt;&amp; prices) {
    vector&lt;int&gt; ans;
    int got = 0;
    double all = 0.0;
    vector&lt;pair&lt;double, int&gt; &gt; s_prices;
    for (int i = 0; i &lt; prices.size(); ++i) {
        double price = prices[i];
        int tmp = int(floor(price));
        got += tmp;
        ans.push_back(tmp);
        all += price;
        s_prices.push_back(make_pair(price, i));
    }
    sort (s_prices.begin(), s_prices.end(),
         [](pair&lt;double, int&gt; a, pair&lt;double, int&gt; b)
         { return a.first - floor(a.first) &gt; b.first - floor(b.first);});
    for (int i = 0; i &lt; int(round(all)) - got; ++i) {
        ans[s_prices[i].second]++;
    }
    return ans;
}
</code></pre><h3 id="2D-itertaor-remove"><a href="#2D-itertaor-remove" class="headerlink" title="2D itertaor + remove()"></a>2D itertaor + remove()</h3><p>leetcode 251（<a href="https://leetcode.com/problems/flatten-2d-vector）" target="_blank" rel="external">https://leetcode.com/problems/flatten-2d-vector）</a><br>实现二维数组的迭代器，加上remove操作。代码如下：</p>
<pre><code>class Vector2D {
private:
    vector&lt;vector&lt;int&gt; &gt;::iterator row, iBegin, iEnd;
    vector&lt;int&gt;::iterator col;
public:
    Vector2D(vector&lt;vector&lt;int&gt; &gt; &amp;nums) {
    row = nums.begin();
    iBegin = nums.begin();
    iEnd = nums.end();
    if (!nums.empty()) col = row-&gt;begin();
    }
    int next() {
        if (hasNext()) {
           int val = *col;
           col++;
           return val;
       }
       throw &quot;It&apos;s empty already!&quot;;
    }
    bool hasNext() {
        while (row != iEnd &amp;&amp; col == row-&gt;end()) {
            ++row;
            if(row != iEnd)
                col = row-&gt;begin();
        }
        return row != iEnd;
    }
    void remove() {
        if (col == row-&gt;begin()) {
            auto pre = prev(row);
            while (pre != iBegin &amp;&amp; (*pre).empty())
                pre = prev(pre);
            if (!(*pre).empty()) {
                (*pre).erase(prev((*pre).end()));
            } else {
                throw &quot;Should call next() first!&quot;;
            }
        } else {
            (*row).erase(prev(col));
            col--;
        }
    }
};
</code></pre><h3 id="ip2cidr"><a href="#ip2cidr" class="headerlink" title="ip2cidr"></a>ip2cidr</h3><p>给出一个ipv4的range，找出最少的cidr可以覆盖这个range内的所有ip。</p>
<p>参考：<br>背景介绍<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing</a><br>这个是个online转化工具<a href="http://www.ipaddressguide.com/cidr" target="_blank" rel="external">http://www.ipaddressguide.com/cidr</a><br>大概的思路是group as much IPs as you can.<br>描述起来还真的麻烦呢，建议跑几个case，就理解了 </p>
<p>code: <a href="http://stackoverflow.com/questions/33443914/how-to-convert-ip-address-range-to-cidr-in-java" target="_blank" rel="external">http://stackoverflow.com/questions/33443914/how-to-convert-ip-address-range-to-cidr-in-java</a></p>
<p>解释： ——代表end-start能覆盖到的二进制位</p>
<p>start：xxxxxxx100000</p>
<p>end：  xxxxxx——-这种情况下，先找出可以覆盖住xxxxxxx100000~xxxxxxx111111的cidr，start变为xxxxxxx100000 + 100000</p>
<p>end：  xxxxxxxxx—-这种情况下，先找出可以覆盖住xxxxxxx100000~xxxxxxx101111的cidr，start变为xxxxxxx100000 + 10000</p>
<pre><code>def ipToVal(ip):
    ip = ip.split(&quot;.&quot;)
    val = 0
    for x in ip:
        val = (val &lt;&lt; 8) + int(x)
    return val


def ValToIp(val):
    ip, i = [&quot;0&quot;] * 4, 3
    while val:
        ip[i] = str(val % (1 &lt;&lt; 8))
        val /= (1 &lt;&lt; 8)
        i -= 1
    return &quot;.&quot;.join(ip)


def range2cidr(start, end):
    if not start or not end or start.count(&apos;.&apos;) != 3 or end.count(&apos;.&apos;) != 3:
        return None
    start, end = ipToVal(start), ipToVal(end)
    if start &gt; end:
        return None
    ans = []
    while start &lt;= end:
        firstOne = start &amp; (-start)
        maxMask = 32 - int(log(firstOne, 2))
        maxDiff = 32 - int(floor(log(end - start + 1, 2)))
        maxMask = max(maxMask, maxDiff)
        ip = ValToIp(start)
        ans.append(ip + &quot;/&quot; + str(maxMask))
        start += 2 ** (32 - maxMask)
    return ans

//C++
long ipToVal(string ip) {
    long val = 0;
    int i = 0;
    for (int j = 0; i &lt; 4 &amp;&amp; j &lt; ip.length(); ++i) {
        auto nx = ip.find(&apos;.&apos;, j);
        if (nx == ip.npos) {
            val = (val &lt;&lt; 8) + atoi(ip.substr(j).c_str());
            ++i;
            break;
        }
        val = (val &lt;&lt; 8) + atoi(ip.substr(j, nx - j).c_str());
        j = nx + 1;
    }
    if (i != 4) throw &quot;The ip is incorrect&quot;;
    return val;
}

string valToIp(long val) {
    string ip = &quot;&quot;;
    for (int i = 0; i &lt; 4; ++i) {
        ip = to_string(val % 256) + &quot;.&quot; + ip;
        val /= 256;
    }
    ip.pop_back();
    return ip;
}


vector&lt;string&gt; range2cidr(string start, string end) {
    // try...catch
    long st = ipToVal(start), ed = ipToVal(end);
    vector&lt;string&gt; ans;
    while (st &lt;= ed) {
        int lastOne = st &amp; (-st);
        int maxMask = 32 - int((log(lastOne)/log(2)));
        int maxDiff = 32 - int(floor(log(ed - st + 1)/log(2)));
        maxMask = max(maxMask, maxDiff);
        string ip = valToIp(st);
        ans.push_back(ip + &quot;/&quot; + to_string(maxMask));
        st += int(pow(2, 32 - maxMask));
    }
    return ans;
}
</code></pre><h3 id="Display-Page-list"><a href="#Display-Page-list" class="headerlink" title="Display Page list"></a>Display Page list</h3><p>用一个set来保存是否出现，加入以后删除原有元素，不够的话顺序补充</p>
<pre><code>vector&lt;vector&lt;string&gt; &gt; paging(vector&lt;string&gt; items, int size) {
    vector&lt;vector&lt;string&gt; &gt; ans;
    const int n = items.size();
    for (int i = 0; i &lt;= (n - 1) / size; ++i) {
        vector&lt;string&gt; tmp;
        unordered_set&lt;string&gt; st;
        for (auto it = items.begin(); it != items.end() &amp;&amp; tmp.size() &lt; size;) {
            if (st.count(*it)) {
                ++it;
                continue;
            }
            st.insert(*it);
            tmp.push_back(*it);
            items.erase(it);
        }
        for (auto it = items.begin(); it != items.end() &amp;&amp; tmp.size() &lt; size;) {
            tmp.push_back(*it);
            items.erase(it);
        }
        ans.push_back(tmp);
    }
    return ans;
}
</code></pre><h3 id="menu-order"><a href="#menu-order" class="headerlink" title="menu order"></a>menu order</h3><p>点菜，菜价格为double，问如何正好花完手里的钱<br>解法：把菜单价格*100转成整数，题目转换成leetcode 40.Combination Sum II（<a href="https://leetcode.com/problems/combination-sum-ii/?tab=Description）" target="_blank" rel="external">https://leetcode.com/problems/combination-sum-ii/?tab=Description）</a></p>
<pre><code>void helper(vector&lt;int&gt; &amp;dish, vector&lt;vector&lt;double&gt; &gt; &amp;ans, vector&lt;double&gt; &amp;cur, int idx, int money) {
    if (money == 0) {
        ans.push_back(cur);
        return;
    }
    if (idx == dish.size() || money &lt; 0 || money &lt; dish[idx])
        return;
    int cnt = 1;
    while (cnt * dish[idx] &lt;= money) {
        cur.push_back(dish[idx] / 100.0);
        helper(dish, ans, cur, idx + 1, money - cnt * dish[idx]);
        ++cnt;
    }
    while (--cnt) cur.pop_back();
    helper(dish, ans, cur, idx + 1, money);
}

vector&lt;vector&lt;double&gt; &gt; menuOrder(vector&lt;double&gt;&amp; dish, double money) {
    vector&lt;int&gt; tmp;
    vector&lt;vector&lt;double&gt; &gt; ans;
    vector&lt;double&gt; cur;
    for (auto d : dish)
        tmp.push_back(int(d * 100));
    sort(tmp.begin(), tmp.end());
    helper(tmp, ans, cur, 0, int(money * 100));
    return ans;
}
</code></pre><h3 id="Hilbert-Curve"><a href="#Hilbert-Curve" class="headerlink" title="Hilbert Curve"></a>Hilbert Curve</h3><p>Hilbert Curve（<a href="http://bit-player.org/extras/hilbert/hilbert-construction.html）" target="_blank" rel="external">http://bit-player.org/extras/hilbert/hilbert-construction.html）</a><br>Hilbert曲线可以无限阶下去，从1阶开始，落在一个矩阵里，让你写个function，三个参数（x,y,阶数），return 这个点（x,y）是在这阶curve里从原点出发的第几步</p>
<pre><code>int hilbertCurve(int x, int y, int iter) {
    if (iter == 0) return 1;
    int areaCnt = (1 &lt;&lt; (iter * 2 - 2)); // 每一块区域边长的边界值
    int borderLen = (1 &lt;&lt; (iter - 1)); // 区域移动的长度

    if (x &gt;= borderLen &amp;&amp; y &gt;= borderLen) //右上角区域 = 前一阶往右上角移动borderLen
        return areaCnt * 2 + hilbertCurve(x - borderLen, y - borderLen, iter - 1);
    else if (x &lt; borderLen &amp;&amp; y &gt;= borderLen) //左上角区域 = 前一阶往上移动borderLen
        return areaCnt + hilbertCurve(x, y - borderLen, iter - 1);
    else if (x &lt; borderLen &amp;&amp; y &lt; borderLen) //右下角区域 = 前一阶按照y=x对称
        return hilbertCurve(y, x, iter - 1);
    else //右下角区域 = 前一阶按照y=-x对称，然后右移2*borderLen - 1，上移borderLen - 1
    // 设原来坐标(a,b) =&gt; (-b, -a) =&gt; (2*borderLen - 1 - b, borderLen - 1 - a) = (x, y)
    // =&gt; a = borderLen - 1 - y, b = 2*borderLen - 1 - x
        return areaCnt * 3 + hilbertCurve(borderLen - 1 - y, 2 * borderLen - 1 - x, iter - 1);
}
</code></pre><h3 id="Alien-Dictionary"><a href="#Alien-Dictionary" class="headerlink" title="Alien Dictionary"></a>Alien Dictionary</h3><p>leetcode 269</p>
<pre><code>string alienOrder(vector&lt;string&gt; &amp;words) {
    unordered_map&lt;char, unordered_set&lt;char&gt; &gt; mp;
    unordered_map&lt;char, int&gt; idx;
    unordered_set&lt;char&gt; st;
    queue&lt;char&gt; q;
    string ans = &quot;&quot;;
    for (auto word : words) st.insert(word.begin(), word.end());
    for (int i = 0; i &lt; words.size() - 1; ++i) {
        int j = 0, end = min(words[i].size(), words[i + 1].size());
        for (; j &lt; end; ++j) {
            if (words[i][j] == words[i + 1][j]) continue;
            mp[words[i][j]].insert(words[i + 1][j]);
            break;
        }
        if (j == end &amp;&amp; words[i].size() &gt; words[i + 1].size())
            return ans;
    }
    for (auto m : mp) {
        for (auto s : m.second) {
            idx[s]++;
        }
    }
    for (auto s : st) {
        if (!idx.count(s)) {
            q.push(s);
            ans += s;
        }
    }
    while (!q.empty()) {
        char c = q.front();
        q.pop();
        auto next = mp[c];
        for (auto s : next) {
            if (--idx[s] == 0) {
                q.push(s);
                ans += s;
            }
        }
    }
    return ans.size() == st.size() ? ans : &quot;&quot;;
}
</code></pre><h3 id="有向图-求最少的点可以遍历所有点"><a href="#有向图-求最少的点可以遍历所有点" class="headerlink" title="有向图 求最少的点可以遍历所有点"></a>有向图 求最少的点可以遍历所有点</h3><p>（<a href="https://instant.1point3acres.com/thread/201190，https://instant.1point3acres.com/thread/197716）" target="_blank" rel="external">https://instant.1point3acres.com/thread/201190，https://instant.1point3acres.com/thread/197716）</a></p>
<p>解法，scc（strongly connected component）缩点 + 拓扑排序，太尼玛复杂了。。<br>解scc用了Kosaraju算法， 拓扑排序，代码如下：</p>
<pre><code>void dfs(const vector&lt;vector&lt;bool&gt; &gt; &amp;edges, vector&lt;bool&gt; &amp;visited, vector&lt;unordered_set&lt;int&gt; &gt; &amp;components, int idx, int id) {
    visited[idx] = true;
    if (components.size() == id) components.push_back({});
    components[id].insert(idx);
    for (int i = 0; i &lt; edges.size(); ++i) {
        if (edges[i][idx] &amp;&amp; !visited[i]) dfs(edges, visited, components, i, id);
    }
}

void preDFS(const vector&lt;vector&lt;bool&gt; &gt; &amp;edges, vector&lt;bool&gt; &amp;visited, vector&lt;int&gt; &amp;orders, int idx) {
    visited[idx] = true;
    orders.push_back(idx);
    for (int i = 0; i &lt; edges.size(); ++i) {
        if (edges[idx][i] &amp;&amp; !visited[i]) preDFS(edges, visited, orders, i);
    }
}

vector&lt;int&gt; traverse(vector&lt;vector&lt;bool&gt;&gt; &amp;edges) {
    const auto n = edges.size();
    vector&lt;int&gt; ans;
    if (n == 0) return ans;
    vector&lt;bool&gt; visited(n, false);
    vector&lt;int&gt; orders;// 记录伪拓扑排序的顺序
    vector&lt;unordered_set&lt;int&gt; &gt; components;//记录scc都包含哪些元素
    int id = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) {
            preDFS(edges, visited, orders, i);
        }
    }
    fill(visited.begin(), visited.end(), false);
    for (int i = n - 1; i &gt;= 0; --i) {
        if (!visited[orders[i]]) {
            dfs(edges, visited, components, orders[i], id);
            ++id;
        }
    }

    unordered_map&lt;int, int&gt; in;
    unordered_map&lt;int, unordered_set&lt;int&gt; &gt; next;
    for (int from = 0; from &lt; id; ++from) {
        for (int to = 0; to &lt; id; ++to) {
            if (from == to) continue;
            bool found = false;
            for (auto x : components[from]) {
                if (found) break;
                for (auto y : components[to])
                    if (edges[x][y]) {
                        in[to]++;
                        next[from].insert(to);
                        found = true;
                        break;
                    }
            }
        }
    }
    for (int i = 0; i &lt; id; ++i) {
        if (in[i] == 0) {
            ans.push_back(*components[i].begin());
        }
    }
    return ans;
}
</code></pre><p>c++(scc + union search)</p>
<pre><code>typedef pair&lt;int, int&gt; pr;
typedef unordered_map&lt;int, unordered_set&lt;int&gt; &gt; connectInfo;
void fromDFS(int node, connectInfo from, vector&lt;int&gt;&amp; order, unordered_set&lt;int&gt;&amp; visited) {
    if(!visited.count(node)) {
        visited.insert(node);
        for(auto n : from[node])
            fromDFS(n, from, order, visited);
        order.insert(order.begin(), node);
    }
}

void toDFS(int node, int root, connectInfo to, unordered_map&lt;int, int&gt;&amp; components) {
    if(!components.count(node)) {
        components[node] = root;
        for(auto n : to[node])
            toDFS(n, root, to, components);
    }
}

unordered_map&lt;int, int&gt; kosasrajus(connectInfo from, connectInfo to, const unordered_set&lt;int&gt;&amp; nodes) {
    unordered_set&lt;int&gt; visited;
    unordered_map&lt;int, int&gt; components;
    vector&lt;int&gt; order;
    for(auto node : nodes)
        fromDFS(node, from, order, visited);
    for(auto node : order)
        toDFS(node, node, to, components);
    return components;
}

vector&lt;int&gt; least_nodes(const vector&lt;pr&gt;&amp; edges) {
    connectInfo from, to;
    unordered_set&lt;int&gt; nodes;
    vector&lt;int&gt; ans;
    for(auto edge : edges) {
        from[edge.first].insert(edge.second);
        to[edge.second].insert(edge.first);
        nodes.insert(edge.first);
        nodes.insert(edge.second);
    }
    unordered_map&lt;int, int&gt; components = kosasrajus(from, to, nodes);
    unordered_set&lt;int&gt; fromComponents, toComponents;
    for(auto edge : edges) {
        fromComponents.insert(components[edge.first]);
        if(components[edge.first] != components[edge.second]) {
            toComponents.insert(components[edge.second]);
        }
    }
    for(auto node : fromComponents)
        if(!toComponents.count(node))
            ans.push_back(node);
    return ans;
}
</code></pre><p>python:</p>
<pre><code>def least_nodes(edges):
    pred = collections.defaultdict(set)
    succ = collections.defaultdict(set)

    for start, end in edges:
        pred[end].add(start)
        succ[start].add(end)

    components = kosarajus(pred, succ)
    component_pred = collections.defaultdict(set)
    component_succ = collections.defaultdict(set)
    for start, end in edges:
        if components[start] != components[end]:
            component_start = components[start]
            component_end = components[end]

            component_pred[component_end].add(component_start)
            component_succ[component_start].add(component_end)

    return set(component_succ.keys()) - set(component_pred.keys())

def kosarajus(pred, succ):
    all_nodes = set(pred.keys()) | set(succ.keys())

    order = []
    visited = set()
    def visit(node):
        if node not in visited:
            visited.add(node)
            for out_neighbor in succ[node]:
                visit(out_neighbor)
            order.insert(0, node)

    for node in all_nodes:
        visit(node)

    components = {}
    def assign(node, root):
        if node not in components:
            components[node] = root
            for in_neighbor in pred[node]:
                assign(in_neighbor, root)

    for node in order:
        assign(node, node)

    return components
</code></pre><h3 id="meeting-room"><a href="#meeting-room" class="headerlink" title="meeting room"></a>meeting room</h3><p>给一组meetings（每个meeting由start和end时间组成）。求出在所有输入meeting时间段内没有会议，也就是空闲的时间段。每个subarray都已经sort好。N个员工，每个员工有若干个interval表示在这段时间是忙碌的。求所有员工都不忙的intervals。</p>
<p>循环merge，然后遍历空闲区间（ps：另一种解法很简单，参考：这题最简单的方法就是把所有区间都拆成两个点，然后排序，然后扫描，每次碰到一个点如果是左端点就把busy_employees加1，否则减1，等到每次busy_employees为0时就是一个新的区间。这样复杂度O(MlogM)，M是总共区间数。）</p>
<pre><code>//merge and search
vector&lt;pr&gt; merge(vector&lt;pr&gt; ft, vector&lt;pr&gt; sd) {//c++, merge
    if(ft.empty()) return sd;
    if(sd.empty()) return ft;
    vector&lt;pr&gt; ans;
    const int m = ft.size(), n = sd.size();
    int i = 0, j = 0;
    pr tmp(1, 1);
    while(i &lt; m || j &lt; n) {
        if ((i == m || tmp.second &lt; ft[i].first) &amp;&amp; (j == n || tmp.second &lt; sd[j].first)) {
            ans.push_back(tmp);
            if(i == m) tmp = sd[j];
            else if(j == n) tmp = ft[i];
            else {
                tmp.first = min(ft[i].first, sd[j].first);
                tmp.second = min(ft[i].second, sd[j].second);
            }
        }
        if(i &lt; m &amp;&amp; ft[i].first &lt;= tmp.second)
            tmp.second = max(tmp.second, ft[i++].second);
        if(j &lt; n &amp;&amp; sd[j].first &lt;= tmp.second)
            tmp.second = max(tmp.second, sd[j++].second);
    }
    ans.push_back(tmp);
    return ans;
}
vector&lt;pr&gt; meetingRoom(vector&lt;vector&lt;pr&gt; &gt; meetings) {
    vector&lt;pr&gt; ans, tmp;
    const int n = meetings.size();
    if(n == 0) return ans;
    tmp = meetings[0];
    for(int i = 1; i &lt; n; ++i) {
        tmp = merge(tmp, meetings[i]);
    }
    if(tmp[0].first &gt; 1)
        ans.push_back(make_pair(1, tmp[0].first));
    for(int i = 0; i &lt; tmp.size() - 1; ++i)
        ans.push_back(make_pair(tmp[i].second, tmp[i + 1].first));
    return ans;
}

//break and sort: C++
typedef pair&lt;int, int&gt; pr;
typedef pair&lt;int, bool&gt; timePoint;
vector&lt;pr&gt; meetingRoom(vector&lt;vector&lt;pr&gt; &gt; meetings) {
    vector&lt;timePoint&gt; times;
    vector&lt;pr&gt; ans;
    if ( meetings.empty()) return ans;
    for (auto meeting : meetings) {
        for (auto interval : meeting) {
            times.push_back(make_pair(interval.first, true));
            times.push_back(make_pair(interval.second, false));
        }
    }
    sort(times.begin(), times.end());
    int startCnt = 0, preTime = times[0].first;
    for(auto time : times) {
        bool starting = time.second;
        if (starting) {
            if (startCnt == 0 &amp;&amp; time.first &gt; preTime) {
                ans.push_back(make_pair(preTime, time.first));
            }
            ++startCnt;
        } else {
            if (startCnt == 1) preTime = max(preTime, time.first);
            --startCnt;
        }
    }
    return ans;
}

//break and sort: python    
def find_free_time(schedules):
moment_status = []

for person_schedule in schedules:
    for interval in person_schedule:
        moment_status.append((interval[0], True))
        moment_status.append((interval[1], False))
moment_status.sort()
free_start = moment_status[0][0]
busy_count = 0
available_intervals = []
for moment, become_busy in moment_status:
    if become_busy:
        if busy_count == 0:
            if moment &gt; free_start:
                available_intervals.append((free_start, moment))
        busy_count += 1
    else:
        if busy_count == 1:
            free_start = moment
        busy_count -= 1
return available_intervals
</code></pre><h3 id="preference-list"><a href="#preference-list" class="headerlink" title="preference list"></a>preference list</h3><p>每个人都有一个preference的排序，在不违反每个人的preference的情况下得到总体的preference的排序 拓扑排序解决(<a href="https://instant.1point3acres.com/thread/207601" target="_blank" rel="external">https://instant.1point3acres.com/thread/207601</a>)</p>
<pre><code>vector&lt;int&gt; preferenceList(vector&lt;vector&lt;int&gt; &gt; &amp;preList) {
    unordered_map&lt;int, unordered_set&lt;int&gt; &gt; mp;
    unordered_map&lt;int, int&gt; in;
    vector&lt;int&gt; ans;
    for(auto lt : preList) {
        for(int i = 1; i &lt; lt.size(); ++i)
            mp[lt[i - 1]].insert(lt[i]);
    }
    for(auto m : mp)
        for(auto s : m.second)
            in[s]++;
    queue&lt;int&gt; q;
    for(int i = 0; i &lt; preList.size(); ++i)
        if(!in.count(i)) {
            q.push(i);
            ans.push_back(i);
        }
    while(!q.empty()) {
        int c = q.front();
        q.pop();
        auto next = mp[c];
        for(auto s : next) {
            if(--in[s] == 0) {
                q.push(s);
                ans.push_back(s);
            }
        }
    }
    return ans;
}
</code></pre><h3 id="buddy-list"><a href="#buddy-list" class="headerlink" title="buddy list"></a>buddy list</h3><p>你和你的兄弟都有一个wishlist，找出和你相似度最高的。follow up是给出一个max值，找出你的buddy的wishlist里不在你的wishlist里的最多max个城市，根据buddy和你的重合程度来排序 </p>
<p>例如：<br>你的wishlist是 a,b,c,d </p>
<p>buddy1 的wishlist 是 a,b,e,f, 有两个和你的一样，所以是你的buddy </p>
<p>buddy2 的wishlist 是 a,c,d,g, 有三个和你的一样，也是你的budy </p>
<p>问题是输出一个size最多为max的推荐城市列表。当size为10时，buddy1和buddy2的wishlist中不在你的wishlist中的城市都可以加入推荐中，因为buddy2的重合度更高，所以先输出buddy2中的，所以推荐为 g,e,f 当size为2时，推荐是g,e 或 g,f </p>
<p>代码我只写了重合度排名，推荐的话可以按照相似度从高到低遍历，找出不在你的wishlist中的输出，输出过程中可以标记是否已经输出</p>
<pre><code>def find(self, nums, nums2):
    return sorted([(sum([num in set(nums) for num in nums2[i]]) / float(len(nums2[i])), i)
                   for i in xrange(len(nums2))])
</code></pre><h3 id="flight-ticket-list"><a href="#flight-ticket-list" class="headerlink" title="flight ticket list"></a>flight ticket list</h3><p>每一项包括departure, arrival, cost，然后给一个整数k, 表示最多允许k次中转。给定起始地点A，到达地点B, 要求输出从A到B的最小花费，最多k次中转。BFS一层一层扫。</p>
<pre><code>def min_cost(flights, start, end, k):
    info = collections.defaultdict(set)
    for tour, cost in flights:
        st, ed = tour.split(&quot;-&gt;&quot;)
        info[st].add((ed, cost))

    cur_level = {start: 0}
    ans = 0x7FFFFFF
    for _ in xrange(k + 1):
        next_level = {}
        for port, cur_cost in cur_level.iteritems():
            for nx, cost in info[port]:
                if nx == end:
                    ans = min(ans, cost + cur_cost)
                else:
                    if nx not in next_level:
                        next_level[nx] = cost + cur_cost
                    else:
                        next_level[nx] = min(next_level[nx], cost + cur_cost)
        cur_level = next_level
    return ans

///C++: 太丑
typedef pair&lt;string, int&gt; costInfo;
int minCostFlight(const vector&lt;string&gt;&amp; flights, string start, string end, int k) {
    unordered_map&lt;string, set&lt;costInfo&gt; &gt; costMap;
    unordered_map&lt;string, int&gt; reached[2];
    int ans = INT_MAX;
    for (auto flight : flights) 
        auto nx = flight.find(&quot;-&gt;&quot;, 0);
        auto comma = flight.find(&apos;,&apos;, nx + 2);
        string st = flight.substr(0, nx);
        string ed = flight.substr(nx + 2, comma - nx - 2);
        int cost = atoi(flight.substr(comma + 1).c_str());
        costMap[st].insert(make_pair(ed, cost));
    }
    reached[0][start] = 0;
    for (int i = 0, j = 0; i &lt;= k; ++i) {
        int nxIdx = (j + 1) % 2;
        reached[nxIdx].clear();
        for (auto st : reached[j]) {
            for(auto ed : costMap[st.first]) {
                if (ed.first == end) {
                    ans = min(ans, ed.second + st.second);
                } else {
                    if (!reached[nxIdx].count(ed.first))
                        reached[nxIdx][ed.first] = ed.second + st.second;
                    else
                        reached[nxIdx][ed.first] = min(reached[nxIdx][ed.first], ed.second + st.second);
                }
            }
        }
        j = nxIdx;
    }
    return ans;
}
</code></pre><h3 id="URL-Shortener"><a href="#URL-Shortener" class="headerlink" title="URL Shortener"></a>URL Shortener</h3><p>（<a href="https://instant.1point3acres.com/thread/196339）" target="_blank" rel="external">https://instant.1point3acres.com/thread/196339）</a></p>
<p>看描述好像是url里的id如果有某些位置大小写换了会导致原来的url decode有问题，需要重写encode方法，回溯改某些位的大小写判断</p>
<pre><code>class decodeURL {
public:
    int decode(string url) {
        string dUrl = &quot;kljJJ324hijkS_&quot;;
        if (url == dUrl) return 848662;
        return -1;
    }

    int decodeFind(string url) {
        return helper(url, 0);
    }

private:
    int helper(string s, int idx) {
        if (idx == s.length())
            return decode(s);
        if (isalpha(s[idx])) {
            int uid = helper(s.substr(0, idx) + char(tolower(s[idx])) + s.substr(idx + 1), idx + 1);
            int lid = helper(s.substr(0, idx) + char(toupper(s[idx])) + s.substr(idx + 1), idx + 1);
            if (uid != -1 || lid != -1)
                return uid != -1 ? uid : lid;
            return -1;
        } else {
            return helper(s, idx + 1);
        }
    }
};
</code></pre><h3 id="wizards"><a href="#wizards" class="headerlink" title="wizards"></a>wizards</h3><p>There are 10 <strong>wizards</strong>, 0-9, you are given a list that each entry is a list of wizards known by wizard. Define the cost between wizards and wizard as square of different of i and j. To find the min cost between 0 and 9. </p>
<p>说白了，就是带权重的最短距离，最优解是Dijkstra algorithm。似乎面试官说，只要普通的BFS能得到解也是可以的，Dijkstra我最近正好写过，所以也写出来了。（<a href="https://instant.1point3acres.com/thread/218032）" target="_blank" rel="external">https://instant.1point3acres.com/thread/218032）</a></p>
<pre><code>def min_distance(wizards, start=0, end=9):
     # info = collections.defaultdict(set)
    # for idx, wizard in enumerate(wizards):
    #     info[idx] = set(wizard)
    cur_level = {start: 0}
    ans = 0x7FFFFFFF
    for _ in xrange(10):
        next_level = {}
        for idx, cur_cost in cur_level.iteritems():
            if idx &gt;= len(wizards):
                continue
            for nx in wizards[idx]:
                cost = cur_cost + (nx - idx) ** 2
                if nx == end:
                    ans = min(ans, cost)
                else:
                    if nx not in next_level:
                        next_level[nx] = cost
                    else:
                        next_level[nx] = min(next_level[nx], cost)
        cur_level = next_level
    return ans

unordered_map&lt;int, int&gt; bfs(const unordered_map&lt;int, int&gt;&amp; preLevel, unordered_map&lt;int, unordered_set&lt;int&gt; &gt;&amp; next, int&amp; ans, int k, int end) {
    unordered_map&lt;int, int&gt; nextLevel;
    for ( auto pre : preLevel) {
        for (auto nx : next[pre.first]) {
            int dis = (nx - pre.first) * (nx - pre.first) + pre.second;
            if (nx == end) {
                ans = min(ans, dis);
            } else if(!nextLevel.count(nx)) {
                nextLevel[nx] = dis;
            } else
                nextLevel[nx] = min(nextLevel[nx], dis);
        }
    }
    return k == 1 ? nextLevel : bfs(nextLevel, next, ans, k - 1, end);
}

int wizards(const vector&lt;vector&lt;int&gt; &gt; &amp;wizards, int start, int end) {
    unordered_map&lt;int, unordered_set&lt;int&gt; &gt; next;
    unordered_map&lt;int, int&gt; curLevel;
    int ans = INT_MAX;
    curLevel[start] = 0;
    for (int i = 0; i &lt; wizards.size(); ++i) {
        for (auto nx : wizards[i]) {
            next[i].insert(nx);
        }
    }
    bfs(curLevel, next, ans, end, end);
    return ans;
}
</code></pre><h3 id="模拟倒水"><a href="#模拟倒水" class="headerlink" title="模拟倒水"></a>模拟倒水</h3><p>water land。 比如terrian是[3,2,1,2] print出来就是</p>
<p>* </p>
<p>* * &nbsp; *</p>
<p>* * * *</p>
<p>* * * *</p>
<p>然后给你一个dumpPoint，一个waterAmount，比如dumpPoint 1, waterAmount 2，因为有重力，所以是从index 2开始加水</p>
<p>* </p>
<p>* * w *</p>
<p>* * * *</p>
<p>* * * *</p>
<p>terrian两边是最高，模拟，先向左找到非递增的最低点，如果该点和dumpPoint一样高，往右继续找非递增的最低点，如果一样高就放到dumpPoint，不一样的话放置在非递增的最低点</p>
<pre><code>void getWaterLevel(vector&lt;int&gt; &amp;height, int position, int count) {
    if(height.empty()) return;
    const int n = height.size();
    vector&lt;int&gt; water(n, 0);
    while(count--) {
        int putLocation = position;
        int left = position, right = position;
        while(left &gt;= 1) {
            if(height[left - 1] + water[left - 1] &gt; height[left] + water[left]) break;
            --left;
        }
        if(height[left] + water[left] &lt; height[position] + water[position])
            putLocation = left;
        else {
            while(right &lt; n - 1) {
                if(height[right + 1] + water[right + 1] &gt; height[right] + water[right]) break;
                ++right;
            }
            if(height[right] + water[right] &lt; height[position] + water[position])
                putLocation = right;
        }
        water[putLocation]++;
    }

    int highest = 0;
    for(int i = 0; i &lt; n; ++i)
        if(height[i] + water[i] &gt; highest)
            highest = height[i] + water[i];
    for(int h = highest; h &gt;= 1; --h) {
        for(int i = 0; i &lt; n; ++i) {
            if(height[i] + water[i] &lt; h) cout&lt;&lt;&quot; &quot;;
            else if(height[i] &lt; h) cout&lt;&lt;&quot;w&quot;;
            else cout&lt;&lt;&quot;*&quot;;
        }
        cout&lt;&lt;endl;
    }
}
</code></pre><h3 id="text-justification"><a href="#text-justification" class="headerlink" title="text justification"></a>text justification</h3><p>leetcode 68(<a href="https://leetcode.com/problems/text-justification/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/text-justification/?tab=Description</a>)</p>
<pre><code>vector&lt;string&gt; justify(vector&lt;string&gt; &amp;words, int L) {
    vector&lt;string&gt; ans;
    const int n = words.size();
    for (int i = 0; i &lt; n;) {
        int num = 0, len = 0;
        while (i + num &lt; n &amp;&amp; words[i + num].size() + len &lt;= L - num) {
            len += words[i + num].size();
            ++num;
        }
        string tmp = words[i];
        for (int j = 1; j &lt; num; ++j) {
            if (i + num &gt;= n) tmp += &quot; &quot;;
            else tmp += string((L - len) / (num - 1) + (j  &lt;= (L - len) % (num - 1)), &apos; &apos;);
            tmp += words[i + j];
        }
        tmp += string(L - tmp.size(), &apos; &apos;);
        ans.push_back(tmp);
        i += num;
    }
    return ans;
}
</code></pre><h3 id="string-pyramids-transition-matrix"><a href="#string-pyramids-transition-matrix" class="headerlink" title="string pyramids transition matrix"></a>string pyramids transition matrix</h3><p>给一个满二叉树的所有叶子，比如 A B C D E F， 然后给一个map，记录了左右孩子分别给了的时候，父亲节点可能的值。例如 左 A 右 B =》 AC，意味着倒数第二层第一个节点可以是A或者是C。然后要求是给几个字母，问这个树的root节点是否可能是这几个字母之一。follow up是加速，记忆化搜索（不是很好写）。</p>
<pre><code>def generate_status(all_status, matrix):
    if len(all_status) == 1:
        return all_status[0]

    next_all_status = []
    for i in xrange(len(all_status) - 1):
        cur_status = set()
        for first in all_status[i]:
            for second in all_status[i + 1]:
                cur_status |= set(list(matrix[first][second]))
        next_all_status.append(cur_status)

    return generate_status(next_all_status, matrix)


def is_legal_status(nodes, status, matrix):
    all_status = [set(node) for node in nodes]
    return status in generate_status(all_status, matrix)

nodes = &quot;ABCD&quot;
matrix = collections.defaultdict(lambda: collections.defaultdict(list))
matrix[&apos;A&apos;][&apos;A&apos;] = [&apos;B&apos;]
matrix[&apos;A&apos;][&apos;B&apos;] = [&apos;A&apos;, &apos;C&apos;]
matrix[&apos;A&apos;][&apos;C&apos;] = [&apos;D&apos;]
matrix[&apos;A&apos;][&apos;D&apos;] = [&apos;A&apos;]
matrix[&apos;B&apos;][&apos;A&apos;] = [&apos;D&apos;]
matrix[&apos;B&apos;][&apos;B&apos;] = [&apos;B&apos;, &apos;C&apos;]
matrix[&apos;B&apos;][&apos;C&apos;] = [&apos;A&apos;]
matrix[&apos;C&apos;][&apos;D&apos;] = [&apos;B&apos;]
print is_legal_status(nodes, &apos;D&apos;, matrix)

typedef unordered_map&lt;char, unordered_map&lt;char, unordered_set&lt;char&gt; &gt; &gt; matrixInfo;
void generateStatus(vector&lt;unordered_set&lt;char&gt; &gt;&amp; allStatus, matrixInfo&amp; matrix) {
    if (allStatus.size() == 1) return;
    const int n = allStatus.size();
    for (int i = 0; i &lt; n - 1; ++i) {
        unordered_set&lt;char&gt; st;
        for (auto first : allStatus[i]) {
            for (auto second : allStatus[i + 1]) {
                st.insert(matrix[first][second].begin(), matrix[first][second].end());
            }
        }
        allStatus[i] = st;
    }
    allStatus.pop_back();
    generateStatus(allStatus, matrix);
}

bool checkStatus(matrixInfo&amp; matrix, char result, const string status) {
    vector&lt;unordered_set&lt;char&gt; &gt; allStatus;
    for (auto c : status) {
        unordered_set&lt;char&gt; tmp;
        tmp.insert(c);
        allStatus.push_back(tmp);
    }
    generateStatus(allStatus, matrix);
    return allStatus[0].count(result) != 0;
}

int main() {
    matrixInfo mi;
    mi[&apos;A&apos;][&apos;A&apos;].insert(&apos;B&apos;);
    mi[&apos;A&apos;][&apos;B&apos;].insert(&apos;A&apos;);
    mi[&apos;A&apos;][&apos;B&apos;].insert(&apos;C&apos;);
    mi[&apos;A&apos;][&apos;C&apos;].insert(&apos;D&apos;);
    mi[&apos;A&apos;][&apos;D&apos;].insert(&apos;A&apos;);
    mi[&apos;B&apos;][&apos;A&apos;].insert(&apos;D&apos;);
    mi[&apos;B&apos;][&apos;B&apos;].insert(&apos;B&apos;);
    mi[&apos;B&apos;][&apos;B&apos;].insert(&apos;C&apos;);
    mi[&apos;B&apos;][&apos;C&apos;].insert(&apos;A&apos;);
    mi[&apos;C&apos;][&apos;D&apos;].insert(&apos;B&apos;);
    cout&lt;&lt;checkStatus(mi, &apos;A&apos;, &quot;ABCD&quot;)&lt;&lt;endl;
}
</code></pre><h3 id="sliding-game"><a href="#sliding-game" class="headerlink" title="sliding game"></a>sliding game</h3><p>九宫格，一共8个方块，从1-8，一个方块空出来，然后打乱之后通过SLIDE还原，这个题要推广到N宫格，先实现这个游戏，然后对于一个任意的BOARD，要你把他解出来</p>
<pre><code>def dis(x, y):  # A* evaluation func
    return (x - 2) ** 2 + (y - 2) ** 2


def play(board):
    m, n = len(board), len(board[0])
    x, y = 0, 0
    for i in xrange(m):
        for j in xrange(n):
            if board[i][j] == &apos;0&apos;:
                x, y = i, j
    board_key = &apos;&apos;.join(&apos;&apos;.join(row) for row in board)
    heap = [(dis(x, y), x, y, board_key)]
    visited = set()

    while heap:
        _, x, y, cur = heapq.heappop(heap)
        if cur in visited:
            continue
        visited.add(cur)
        if cur == &quot;123456780&quot;:
            return True
        for dx, dy in zip((1, -1, 0, 0), (0, 0, 1, -1)):
            new_x, new_y = x + dx, y + dy
            if 0 &lt;= new_x &lt; m and 0 &lt;= new_y &lt; n:
                pos1, pos2 = x * m + y, new_x * m + new_y
                new_board = list(cur)
                new_board[pos1], new_board[pos2] = new_board[pos2], new_board[pos1]
                heapq.heappush(heap, (dis(new_x, new_y), new_x, new_y, &apos;&apos;.join(new_board)))

    return False

typedef tuple&lt;int, int, int, string&gt; boardInfo;
bool validSlidingGame(vector&lt;vector&lt;int&gt; &gt;&amp; board) {
    const int m = board.size(), n = board[0].size();
    auto dis = [](int x, int y, int z, int p) {return (x - z) * (x - z) + (y - p) * (y - p); };
    int x = 0, y = 0;
    string key = &quot;&quot;;
    const int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    priority_queue&lt;boardInfo&gt; pq;
    unordered_set&lt;string&gt; visited;
    for (int i = 0; i &lt; m; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (board[i][j] == 0) {
                x = i, y = j;
            }
            key += to_string(board[i][j]);
        }
    }
    pq.push(make_tuple(-dis(x, y, m - 1, n - 1), x, y, key));
    visited.insert(key);
    while (!pq.empty()) {
        auto tp = pq.top();
        pq.pop();
        string curKey;
        tie(ignore, x, y, curKey) = tp;
//        x = get&lt;1&gt;(tp), y = get&lt;2&gt;(tp);
//        auto curKey = get&lt;3&gt;(tp);
        if (curKey == &quot;123456780&quot;) return true;
        for (int i = 0; i &lt; 4; ++i) {
            int newX = x + dir[i][0];
            int newY = y + dir[i][1];
            if (newX &gt;= 0 &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; n) {
                swap(curKey[x * m + y], curKey[newX * m + newY]);
                if (!visited.count(curKey)) {
                    pq.push(make_tuple(-dis(newX, newY, m - 1, n - 1), newX, newY, curKey));
                    visited.insert(curKey);
                }
            }
        }
    }
    return false;
}
</code></pre><h3 id="find-median-from-large-file-of-integers"><a href="#find-median-from-large-file-of-integers" class="headerlink" title="find median from large file of integers"></a>find median from large file of integers</h3><p><a href="https://instant.1point3acres.com/thread/159344" target="_blank" rel="external">https://instant.1point3acres.com/thread/159344</a><br>二分查找<br>思路就是：先找在INT_MIN和INT_MAX的median（0？），然后读large file of integers，找出比这个数小的个数是否有一半，然后调整二分的边界</p>
<pre><code>double findNth(int N, int left, int right) {
    while(left &lt;= right){
        int guess = (left + right) / 2;
        int x, cnt = 0, next = right;
        while(x = readFile()) {
            if(x &lt; guess) ++cnt;
            else next = min(next, x);
        }
        if(cnt == N - 1)
            return next;
        if(cnt &lt; N - 1)
            left = guess;
        else
            right = guess - 1;
    }
    return 0.0;
}

double findMedian() {
    int len = 0;
    while(readFile()) ++len;
    if(len &amp; 0x1) return findNth(len &gt;&gt; 1, INT_MIN, INT_MAX);
    int x = findNth(len &gt;&gt; 1, INT_MIN, INT_MAX);
    int y = findNth(1 + (len &gt;&gt; 1), x, INT_MAX);
    return double(x + y) / 2;
}
</code></pre><h3 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h3><p>但是string里面的数可以为负</p>
<p>leetcode 43题，多了个负数的情况（<a href="https://leetcode.com/problems/multiply-strings/?tab=Description）" target="_blank" rel="external">https://leetcode.com/problems/multiply-strings/?tab=Description）</a></p>
<pre><code>#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

typedef vector&lt;int&gt; bigInt;
bigInt make_bigInt(string num) {
    bigInt tmp;
    transform(num.rbegin(), num.rend(), back_inserter(tmp), [](char c) { return c - &apos;0&apos;;});
    return tmp;
}
string make_string(bigInt num) {
    string tmp;
    transform(find_if(num.rbegin(), prev(num.rend()), [](int c){ return c != 0;}), num.rend(),
              back_inserter(tmp), [](int c) { return c + &apos;0&apos;;});
    return tmp;
}
bigInt multiply(bigInt const&amp; n1, bigInt const&amp; n2) {
    bigInt n(n1.size() + n2.size());
    for (int i = 0; i &lt; n1.size(); ++i)
        for (int j = 0; j &lt; n2.size(); ++j) {
            n[i + j] += n1[i] * n2[j];
            n[i + j + 1] += n[i + j] / 10;
            n[i + j] %= 10;
        }
    return n;
}

string multiply(string num1, string num2) {
    if(num1.empty() || num2.empty()) return &quot;0&quot;;
    bool sign = true;
    if (num1[0] == &apos;-&apos; || num1[0] == &apos;+&apos;) {
        if (num1[0] == &apos;-&apos;) sign = !sign;
        num1.sustr(1);
    }
    if (num2[0] == &apos;-&apos; || num2[0] == &apos;+&apos;) {
         if (num2[0] == &apos;-&apos;) sign = !sign;
        num2.sustr(1);
    }
    string ans = make_string(multiply(make_bigInt(num1), make_bigInt(num2)));
    if (ans == &quot;0&quot;) return ans;
    return (sign ? &quot;&quot; : &quot;-&quot;) + ans;
}
</code></pre><h3 id="CSV-PARSER"><a href="#CSV-PARSER" class="headerlink" title="CSV PARSER"></a>CSV PARSER</h3><p>举个例子:<br>给定一个CSV文件，格式是 “some_name|some_address|some_phone|some_job”<br>要求输出Json format “{name:some_name, address:some_addres,phone:some_phone, job:some_job}”<br>输入内容中有些特殊符号要注意处理</p>
<pre><code>vector&lt;string&gt; parseCSV(string s) {
    vector&lt;string&gt; ans;
    bool inQuote = false;
    string tmp = &quot;&quot;;
    for(int i = 0; i &lt; s.length(); ++i) {
        if(inQuote) {
            if(s[i] == &apos;&quot;&apos;) {
                if(i == s.length() - 1) {
                    ans.push_back(tmp);
                    return ans;
                } else if(s[i + 1] == &apos;&quot;&apos;) {
                    tmp += &apos;&quot;&apos;;
                    ++i;
                } else {
                    ans.push_back(tmp);
                    tmp = &quot;&quot;;
                    inQuote = false;
                    i++;
                }
            } else tmp += s[i];
        } else {
            if(s[i] == &apos;&quot;&apos;)
                inQuote = true;
            else if(s[i] == &apos;,&apos;) {
                ans.push_back(tmp);
                tmp = &quot;&quot;;
            } else tmp += s[i];
        }
    }
    if(!tmp.empty()) ans.push_back(tmp);
    return ans;
}

int main() {
    string ss[] = {&quot;John,Smith,john.smith@gmail.com,Los Angeles,1&quot;, &quot;\&quot;Alexandra \&quot;\&quot;Alex\&quot;\&quot;\&quot;,Menendez,alex.menendez@gmail.com,Miami,1&quot;};
    for(auto s : ss) {
        auto parsed = parseCSV(s);
        for (int i = 0; i &lt; parsed.size() - 1; ++i)
            cout &lt;&lt; parsed[i] &lt;&lt; &quot;|&quot;;
        cout&lt;&lt;parsed[parsed.size() - 1]&lt;&lt;endl;
    }
    return 0;
}
</code></pre><h3 id="boggle-game"><a href="#boggle-game" class="headerlink" title="boggle game"></a>boggle game</h3><p>（<a href="https://instant.1point3acres.com/thread/201695）" target="_blank" rel="external">https://instant.1point3acres.com/thread/201695）</a></p>
<p>这题面试来搞也太变态了，先用trie找出所有单词出现的路径map，然后dfs找出map里不重复的最大的。代码未验证~</p>
<pre><code>struct Node {
    bool isWord = false;
    string word;
    Node *next[26];
    Node() {}
};

struct Trie {
    Node *root;
    Trie() {
        root = new Node();
    }

    void buildTrie(const vector&lt;string&gt;&amp; &amp;words) {
        for(auto word : words) {
            Node *cur = root;
            for(auto c : word) {
                int idx = c - &apos;a&apos;;
                if(!cur-&gt;next[idx])
                    cur-&gt;next[idx] = new Node();
                cur = cur-&gt;next[idx];
            }
            cur-&gt;isWord = true;
            cur-&gt;word = word;
        }
    }
};

const int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
void searchBoard(const vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;vector&lt;bool&gt; &gt;&amp; visited, int x, int y, Node* root,
                  vector&lt;pr&gt;&amp; path, unordered_map&lt;string, vector&lt;vector&lt;pr&gt;&gt; &gt;&amp; mp) {
    if(x &lt; 0 || x &gt; board.size() || y &lt; 0 || y &gt; board[0].size() || visited[x][y])
        return;
    int idx = board[x][y] - &apos;a&apos;;
    if(!root-&gt;next[idx]) return;
    root = root-&gt;next[idx];
    path.push_back(make_pair(x, y));
    visited[x][y] = true;
    if(root-&gt;isWord) mp[root-&gt;word].push_back(path);
    for(int i = 0;i &lt; 4; ++i)
        searchBoard(board, visited, x + dir[i][0], y + dir[i][1], root, path, mp);
    visited[x][y] = false;
    path.pop_back();
}
void dfs(int&amp; ans, int cur, const vector&lt;string&gt;&amp; words, vector&lt;vector&lt;bool&gt; &gt;&amp; visited, 
         unordered_map&lt;string, vector&lt;vector&lt;pr&gt;&gt; &gt;&amp; mp, int idx) {
    if(idx == words.size()) {
        ans = max(ans, cur);
        return;
    }
    if(ans &gt;= cur + words.size() - idx) return;
    string word = words[idx];
    if(mp.count(word)) {
        for (auto pts : mp[word]) {
            int cnt = 0;
            for (auto pt : pts) {
                if (visited[pt.first][pt.second]) break;
                cnt++;
            }
            if (cnt == word.size()) {
                for (auto pt : pts) visited[pt.first][pt.second] = true;
                dfs(ans, cur + 1, words, visited, mp, idx + 1);
                for (auto pt : pts) visited[pt.first][pt.second] = false;
            }
        }
    }
    dfs(ans, cur, words, visited, mp, idx + 1);
}

int findWords(const vector&lt;vector&lt;char&gt; &gt;&amp; board, const vector&lt;string&gt;&amp; words) {
    if(board.empty() || words.empty()) return 0;
    Trie trie;
    trie.buildTrie(words);
    const auto m = board.size(), n = board[0].size();
    unordered_map&lt;string, vector&lt;vector&lt;pr&gt;&gt; &gt; mp;
    for(int i = 0; i &lt; m; ++i)
        for(int j = 0; j &lt; n; ++j) {
            vector&lt;vector&lt;bool&gt; &gt; visited(m, vector&lt;bool&gt;(n, false));
            vector&lt;pr&gt; path;
            searchBoard(board, visited, i, j, trie.root, path, mp);
        }
    vector&lt;vector&lt;bool&gt; &gt; visited(m, vector&lt;bool&gt;(n, false));
    int ans = 0;
    dfs(ans, 0, words, visited, mp, 0);
    return ans;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间面试了airbnb北京，顺便整理了下网上能搜到的面经，刷了一遍，主要是coding部分。&lt;br&gt;
    
    </summary>
    
      <category term="面试汇总" scheme="https://yezizp2012.github.io/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="算法" scheme="https://yezizp2012.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="https://yezizp2012.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Ubuntu+jpeg-turbo编译opencv3</title>
    <link href="https://yezizp2012.github.io/2017/05/17/Docker-Ubuntu-jpeg-turbo%E7%BC%96%E8%AF%91opencv3/"/>
    <id>https://yezizp2012.github.io/2017/05/17/Docker-Ubuntu-jpeg-turbo编译opencv3/</id>
    <published>2017-05-17T07:07:08.000Z</published>
    <updated>2017-05-17T07:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用docker构建标准的编译环境<br><a id="more"></a></p>
<h3 id="install-docker"><a href="#install-docker" class="headerlink" title="install docker"></a>install docker</h3><p>docker安装很简单，直接<a href="https://www.docker.com/" target="_blank" rel="external">官网</a>下载安装即可。</p>
<h3 id="pull-ubuntu14-04-image"><a href="#pull-ubuntu14-04-image" class="headerlink" title="pull ubuntu14.04 image"></a>pull ubuntu14.04 image</h3><pre><code>$ docker pull ubuntu:14.04
</code></pre><h3 id="run-container"><a href="#run-container" class="headerlink" title="run container"></a>run container</h3><pre><code>$ docker run --rm -it -v $PWD:/build ubuntu:14.04
</code></pre><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><h4 id="install-build-essential"><a href="#install-build-essential" class="headerlink" title="install build-essential"></a>install build-essential</h4><pre><code>$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install build-essential
</code></pre><h4 id="install-libjpeg-turbo-1-5-1"><a href="#install-libjpeg-turbo-1-5-1" class="headerlink" title="install libjpeg-turbo-1.5.1"></a>install libjpeg-turbo-1.5.1</h4><pre><code>$ wget https://launchpad.net/ubuntu/+archive/primary/+files/libjpeg-turbo_1.5.1.orig.tar.gz
$ tar xvf libjpeg-turbo_1.5.1.orig.tar.gz
$ cd libjpeg-turbo-1.5.1/
$ sudo apt-get install nasm
$ sudo apt-get install dh-autoreconf
$ autoreconf -fiv
$ mkdir build
$ cd build
$ sh ../configure --prefix=/usr/libjpeg-turbo --mandir=/usr/share/man --with-jpeg8 --enable-static --docdir=/usr/share/doc/libjpeg-turbo-1.5.1

# 修改Makefile，把CC: gcc改成CC: gcc -fPIC
# &quot;-fPIC&quot; which was an abbreviation for Position Independent Code, and this had to be passed to create library code objects, without that flag, code that is specific to the source would be used, and then the library would fail.
vi Makefile  =&gt; CC: gcc  -&gt;  CC: gcc -fPIC

$ sudo make
# test:
    $ make test
# install:
    $ make install
</code></pre><h4 id="install-opencv"><a href="#install-opencv" class="headerlink" title="install opencv"></a>install opencv</h4><pre><code>$ wget https://github.com/opencv/opencv/archive/3.2.0.zip
$ mkdir build
$ cd build

# Dependence:
# install cmake
$ wget https://cmake.org/files/v3.8/cmake-3.8.1.tar.gz
$ tar xf cmake-3.8.1.tar.gz
$ cd cmake-3.8.1
$ ./configure
$ make
$ sudo apt-get install checkinstall
$ sudo checkinstall
$ sudo make install
# install others
$ sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev
$ sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev

$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_EXAMPLES=ON -DWITH_JPEG=ON -DBUILD_JPEG=OFF -DJPEG_INCLUDE_DIR=/usr/libjpeg-turbo/include -DJPEG_LIBRARY=/usr/libjpeg-turbo/lib/libjpeg.a ..
#（中间出现ippicv相关包下载hash unmatch error，重新下载包，替换相应目录）
$ sudo make
$ sudo make install
</code></pre><h3 id="save-image"><a href="#save-image" class="headerlink" title="save image"></a>save image</h3><pre><code>docker commit Container_ID new_image:tag
docker save new_image:tag &gt; new_iamge.tar
新的image在其他docker机器上load即可
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/libjpeg.html" target="_blank" rel="external">linuxfromscratch-libjpeg-turbo</a></li>
<li><a href="http://www.linuxfromscratch.org/blfs/view/svn/general/opencv.html" target="_blank" rel="external">linuxfromscratch-opencv3</a></li>
<li><a href="http://cubieboard.blogspot.com/2013/02/raspbian-opencv-libjpeg-turbo.html" target="_blank" rel="external">Raspbian + OpenCV + libjpeg-turbo</a></li>
<li><a href="http://hopkinsdev.blogspot.com/2016/06/opencv-310-optimized-for-raspberry-pi.html" target="_blank" rel="external">openCV 3.1.0 optimized for Raspberry Pi, with libjpeg-turbo 1.5.0 and NEON SIMD support</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用docker构建标准的编译环境&lt;br&gt;
    
    </summary>
    
      <category term="工作琐记" scheme="https://yezizp2012.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%90%90%E8%AE%B0/"/>
    
    
      <category term="opencv3" scheme="https://yezizp2012.github.io/tags/opencv3/"/>
    
      <category term="docker" scheme="https://yezizp2012.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Next Greater Element II</title>
    <link href="https://yezizp2012.github.io/2017/02/15/Next%20Greater%20Element%20II/"/>
    <id>https://yezizp2012.github.io/2017/02/15/Next Greater Element II/</id>
    <published>2017-02-15T03:50:09.000Z</published>
    <updated>2017-02-15T04:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<a id="more"></a>
<p>Example 1:</p>
<pre><code>Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1&apos;s next greater number is 2; 
The number 2 can&apos;t find next greater number; 
The second 1&apos;s next greater number needs to search circularly, which is also 2.
</code></pre><p>Note: The length of given array won’t exceed 10000.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目的意思是：<br>找出数组中每一个数后面第一个大于这个数的数（可循环），不存在为-1</p>
<p>解法：<br>和<a href="/2017/02/15/Next%20Greater%20Element%20I/">Next Greater Element I</a>类似，借助stack，通过比较、入栈和出栈更新数后面第一个大于这个数的数。不同的是不需要map，因为可以循环查找，所以最好还需要遍历一遍数组，代码如下：<br><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type nums: List[int]</div><div class="line">    :rtype: List[int]</div><div class="line">    """</div><div class="line">    s, result = [], [<span class="number">-1</span>] * len(nums)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">        <span class="keyword">while</span> len(s) <span class="keyword">and</span> nums[s[<span class="number">-1</span>]] &lt; nums[i]:</div><div class="line">            result[s[<span class="number">-1</span>]] = nums[i]</div><div class="line">            s.pop()</div><div class="line">        s.append(i)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">        <span class="keyword">while</span> len(s) <span class="keyword">and</span> nums[s[<span class="number">-1</span>]] &lt; nums[i]:</div><div class="line">            result[s[<span class="number">-1</span>]] = nums[i]</div><div class="line">            s.pop()</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure><br><figure class="highlight cpp"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(nums.size(), <span class="number">-1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i]) &#123;</div><div class="line">            result[s.top()] = nums[i];</div><div class="line">            s.pop();</div><div class="line">        &#125;</div><div class="line">        s.push(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() &amp;&amp; !s.empty(); ++i) &#123;</div><div class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i]) &#123;</div><div class="line">            result[s.top()] = nums[i];</div><div class="line">            s.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://yezizp2012.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="stack" scheme="https://yezizp2012.github.io/tags/stack/"/>
    
      <category term="数组" scheme="https://yezizp2012.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Next Greater Element I</title>
    <link href="https://yezizp2012.github.io/2017/02/15/Next%20Greater%20Element%20I/"/>
    <id>https://yezizp2012.github.io/2017/02/15/Next Greater Element I/</id>
    <published>2017-02-15T03:38:09.000Z</published>
    <updated>2017-02-15T03:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<a id="more"></a>
<p>Example 1:</p>
<pre><code>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.
</code></pre><p>Example 2:</p>
<pre><code>Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
</code></pre><p>Note:</p>
<ul>
<li>All elements in nums1 and nums2 are unique.</li>
<li>The length of both nums1 and nums2 would not exceed 1000.</li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目的意思是：<br>找出数组中某一些数后面第一个大于这个数的数，不存在为-1</p>
<p>解法：<br>借助stack和map，通过比较、入栈和出栈更新数后面第一个大于这个数的数。代码如下：<br><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, findNums, nums)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type findNums: List[int]</div><div class="line">    :type nums: List[int]</div><div class="line">    :rtype: List[int]</div><div class="line">    """</div><div class="line">    mp = collections.defaultdict(int)</div><div class="line">    s, result = [], []</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</div><div class="line">        <span class="keyword">while</span> len(s) <span class="keyword">and</span> s[<span class="number">-1</span>] &lt; n:</div><div class="line">            mp[s[<span class="number">-1</span>]] = n</div><div class="line">            s.pop()</div><div class="line">        s.append(n)</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> findNums:</div><div class="line">        result.append(mp.get(n, <span class="number">-1</span>))</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure><br><figure class="highlight cpp"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums) &#123;</div><div class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt; n) &#123;</div><div class="line">            mp[s.top()] = n;</div><div class="line">            s.pop();</div><div class="line">        &#125;</div><div class="line">        s.push(n);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : findNums)</div><div class="line">        result.push_back(mp.count(n) ? mp[n] : <span class="number">-1</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.&lt;/p&gt;
&lt;p&gt;The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://yezizp2012.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="stack" scheme="https://yezizp2012.github.io/tags/stack/"/>
    
      <category term="数组" scheme="https://yezizp2012.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Longest Palindromic Subsequence</title>
    <link href="https://yezizp2012.github.io/2017/02/10/Longest%20Palindromic%20Subsequence/"/>
    <id>https://yezizp2012.github.io/2017/02/10/Longest Palindromic Subsequence/</id>
    <published>2017-02-10T03:38:14.000Z</published>
    <updated>2017-02-10T05:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<a id="more"></a>
<p>Example 1:<br>Input:</p>
<pre><code>&quot;bbbab&quot;
</code></pre><p>Output:</p>
<pre><code>4
</code></pre><p>One possible longest palindromic subsequence is “bbbb”.<br>Example 2:<br>Input:</p>
<pre><code>&quot;cbbd&quot;
</code></pre><p>Output:</p>
<pre><code>2
</code></pre><p>One possible longest palindromic subsequence is “bb”.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目的意思是：</p>
<p>找出字符串中最长的回文子序列（可不连续），显然可以用dp来解，有以下递推公式：</p>
<pre><code>dp[i][j] = max(dp[i+1][j-1]+2(s[i]==s[j]), dp[i+1][j], dp[i][j-1])
其中 dp[k][k] = 1
</code></pre><p>代码如下：<br><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type root: TreeNode</div><div class="line">    :rtype: List[int]</div><div class="line">    """</div><div class="line">    dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</div><div class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> xrange(<span class="number">1</span>, len(s)):</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(s) - g):</div><div class="line">            <span class="keyword">if</span> s[i] == s[i + g]:</div><div class="line">                dp[i][i + g] = <span class="number">2</span> <span class="keyword">if</span> g == <span class="number">1</span> <span class="keyword">else</span> dp[i + <span class="number">1</span>][i + g - <span class="number">1</span>] + <span class="number">2</span></div><div class="line">            dp[i][i + g] = max(dp[i][i + g], dp[i + <span class="number">1</span>][i + g])</div><div class="line">            dp[i][i + g] = max(dp[i][i + g], dp[i][i + g - <span class="number">1</span>])</div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len(s) - <span class="number">1</span>] <span class="keyword">if</span> len(s) <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure><br><figure class="highlight cpp"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> length = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(length, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length, <span class="number">1</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = <span class="number">1</span>; gap &lt; length; ++gap) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + gap &lt; length; ++i) &#123;</div><div class="line">                <span class="keyword">if</span>(s[i] == s[i + gap]) </div><div class="line">                    dp[i][i + gap] = (gap == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">2</span> + dp[i + <span class="number">1</span>][i + gap - <span class="number">1</span>]);</div><div class="line">                dp[i][i + gap] = max(dp[i][i + gap], dp[i + <span class="number">1</span>][i + gap]);</div><div class="line">                dp[i][i + gap] = max(dp[i][i + gap], dp[i][i + gap - <span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的代码还可以优化，空间复杂度为O(N^2)，通过回滚数组可以把空间降低到O(N)。（参考：<a href="https://discuss.leetcode.com/topic/78625/python-o-n-space-o-n-2-time）" target="_blank" rel="external">https://discuss.leetcode.com/topic/78625/python-o-n-space-o-n-2-time）</a><br><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type s: str</div><div class="line">    :rtype: int</div><div class="line">    """</div><div class="line">    dp = [<span class="number">1</span>] * len(s)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, len(s)):</div><div class="line">        pre = dp[j]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(xrange(<span class="number">0</span>, j)):</div><div class="line">            tmp = dp[i] <span class="comment"># actually means result of i+1~j-1</span></div><div class="line">            <span class="keyword">if</span> s[i] == s[j]:</div><div class="line">                dp[i] = <span class="number">2</span> + pre <span class="keyword">if</span> i + <span class="number">1</span> &lt;= j - <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                dp[i] = max(dp[i + <span class="number">1</span>], dp[i])</div><div class="line">            pre = tmp</div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://yezizp2012.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://yezizp2012.github.io/tags/dp/"/>
    
      <category term="字符串" scheme="https://yezizp2012.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Most Frequent Subtree Sum</title>
    <link href="https://yezizp2012.github.io/2017/02/09/Most%20Frequent%20Subtree%20Sum/"/>
    <id>https://yezizp2012.github.io/2017/02/09/Most Frequent Subtree Sum/</id>
    <published>2017-02-09T09:28:06.000Z</published>
    <updated>2017-02-10T05:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>
<a id="more"></a>
<p>Examples 1<br>Input:</p>
<pre><code>  5
 /  \
2   -3
</code></pre><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.<br>Examples 2<br>Input:</p>
<pre><code>  5
 /  \
2   -5
</code></pre><p>return [2], since 2 happens twice, however -5 only occur once.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目的意思是：</p>
<p>以二叉树里的所有节点作为root的子二叉树称为subtree，这些subtree的所有节点之和称为subtree sum。现在需要统计所有子二叉树的subtree sum出现次数最多的root节点。</p>
<p>解法：<br>递归遍历所有二叉树，记录subtree sum和子树的和。代码如下：<br><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        self.info.clear()</div><div class="line">        self.calFrequentInfo(root)</div><div class="line">        cnt = self.info[max(self.info, key=self.info.get)] <span class="keyword">if</span> root <span class="keyword">else</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> [key <span class="keyword">for</span> key, val <span class="keyword">in</span> self.info.items() <span class="keyword">if</span> val == cnt]</div><div class="line"></div><div class="line">    info = collections.defaultdict(int)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calFrequentInfo</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        value = root.val + self.calFrequentInfo(root.left) + self.calFrequentInfo(root.right)</div><div class="line">        self.info[value] += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> value</div></pre></td></tr></table></figure><br><figure class="highlight cpp"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findFrequentTreeSum(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        calFrequentInfo(root, mp, maxCnt);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : mp) &#123;</div><div class="line">            <span class="keyword">if</span>(x.second == maxCnt)</div><div class="line">                result.push_back(x.first);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calFrequentInfo</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;mp, <span class="keyword">int</span> &amp;maxCnt)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> value = root-&gt;val + calFrequentInfo(root-&gt;left, mp, maxCnt) + calFrequentInfo(root-&gt;right, mp, maxCnt);</div><div class="line">        mp[value]++;</div><div class="line">        maxCnt = max(maxCnt, mp[value]);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://yezizp2012.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://yezizp2012.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://yezizp2012.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章8.对象</title>
    <link href="https://yezizp2012.github.io/2017/02/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A08-%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yezizp2012.github.io/2017/02/06/Redis设计与实现笔记-章8-对象/</id>
    <published>2017-02-06T03:50:50.000Z</published>
    <updated>2017-02-10T09:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面7章介绍了redis在底层用到的所有数据结构：<code>SDS</code>，<code>双端链表</code>，<code>字典</code>，<code>skiplist</code>，<code>整数集合</code>，<code>ziplist</code>。redis没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构实现了一个对象系统，包括以下五种类型：<code>字符串对象</code>，<code>列表对象</code>，<code>哈希对象</code>，<code>集合对象</code>和<code>有序集合对象</code>。每种对象系统使用了至少一种前面的数据结构。对象系统带给redis的好处主要有以下几个方面：</p>
<ul>
<li>通过这五种不同类型的对象，redis在执行不同命令的时候可以对对象的类型进行检查，看该命令是否可以执行</li>
<li>在不同的应用场景中，同一类对象可以针对不同的应用场景选择不同的数据结构实现，优化使用效率</li>
<li>对象系统实现了基于引用技术的内存回收机制，对不再使用的对象进行回收。另外，通过引用技术可以实现对象共享机制，在适当的条件下达到对象共享，节约内存</li>
<li>对象带有访问时间记录，可以计算数据库键的空转时长，在服务器启用<code>maxmemory</code>功能时来确定删除优先级</li>
</ul>
<a id="more"></a>
<h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>redis使用对象来表示数据库中的键和值，当我们在redis中新建一个键值对时，至少会创建两个对象（例：<code>SET msg &quot;hello world&quot;</code>会创建包含字符串值”msg”的对象和包含字符串值”hello world”的对象）。键总是一个<code>字符串对象</code>，而值可以是五种对象中的任意一个。<br><figure class="highlight c"><figcaption><span>redis.h/redisObject</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/redis.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr;<span class="comment">// 指向实际值的指针</span></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，类型可以是以下几个常量：<br><figure class="highlight c"><figcaption><span>redis.h/redisObject</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/redis.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象类型</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></div></pre></td></tr></table></figure><br>在redis中，用<code>TYPE</code>命令对键进行操作时，返回的是值的类型。五种类型返回值分别为：<code>string</code>，<code>list</code>，<code>hash</code>，<code>set</code>和<code>zset</code>。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET msg <span class="string">"hello world"</span></div><div class="line">OK</div><div class="line">redis&gt; TYPE msg</div><div class="line">string</div><div class="line">redis&gt; RPUSH numbers 1 3 5</div><div class="line">(<span class="built_in">integer</span>) 6</div><div class="line">redis&gt; TYPE numbers</div><div class="line">list</div></pre></td></tr></table></figure></p>
<h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>对象的encoding属性记录了对象所使用的编码，不同的编码代表了不同的底层数据结构实现。编码可以是以下几个常量，对应的数据结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">对应底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">REDIS_ENCODING_RAW 0</td>
<td style="text-align:left">简单动态字符串SDS</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_INT 1</td>
<td style="text-align:left">long类型的整数</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_HT 2</td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_ZIPMAP 3</td>
<td style="text-align:left">zipmap表示小hash，redis2.6后用ziplist代替</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_LINKEDLIST 4</td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_ZIPLIST 5</td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_INTSET 6</td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_SKIPLIST 7</td>
<td style="text-align:left">跳表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_EMBSTR 8</td>
<td style="text-align:left">embstr编码的简单动态字符串SDS</td>
</tr>
</tbody>
</table>
<p>通过对象的type属性和encoding属性，可以确定该对象是用何种底层数据结构实现的何种对象类型。事实上，每种类型的对象都至少有两种不同的编码，即存在至少两种不同的底层数据结构实现，具体在后面描述。</p>
<p>在redis中，用<code>OBJECT ENCODING</code>命令来查看数据库键的值对象的编码。返回值为：<code>raw</code>，<code>int</code>，<code>hashtable</code>，<code>linkedlist</code>，<code>ziplist</code>，<code>intset</code>，<code>skiplist</code>，<code>embstr</code>。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET msg <span class="string">"hello world"</span></div><div class="line">OK</div><div class="line">redis&gt; OBJECT ENCODING msg</div><div class="line"><span class="string">"embstr"</span></div><div class="line">redis&gt; SET story <span class="string">"long long ago, ..."</span></div><div class="line">OK</div><div class="line">redis&gt; OBJECT ENCODING story</div><div class="line"><span class="string">"raw"</span></div><div class="line">redis&gt; SADD numbers 1 3 5</div><div class="line">(<span class="built_in">integer</span>) 3</div><div class="line">redis&gt; OBJECT ENCODING numbers</div><div class="line"><span class="string">"intset"</span></div><div class="line">redis&gt; SADD numbers <span class="string">"seven"</span></div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis&gt; OBJECT ENCODING numbers</div><div class="line"><span class="string">"hashtable"</span></div></pre></td></tr></table></figure><br>使用不同的底层数据结构来实现不同的对象，在元素较少时可以节约内存，连续的存储可以快速载入等。至于具体在哪种场景下使用哪种编码、什么时候切换、相同命令在不同编码下的实现等，按不同对象来进行分析。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是<code>int</code>，<code>raw</code>，<code>embstr</code>：</p>
<ul>
<li>当一个字符串对象保存的是整数值，且这个整数值可以用long类型来表示时，会将编码设置成<code>int</code>，ptr指向该整数，不在<code>LONG_MIN</code>~<code>LONG_MAX</code>范围的转string用SDS保存（<code>sdsfromlonglong</code>）。另外，在0~10000（<code>REDIS_SHARED_INTEGERS</code>）范围内的用共享整数对象</li>
<li>当保存对象是一个字符串，且字符串长度大于39字节（<code>REDIS_ENCODING_EMBSTR_SIZE_LIMIT</code>）时，使用SDS来保存这个字符串，编码设置为<code>raw</code></li>
<li>当保存对象是一个字符串，且字符串长度不大于39字节时，使用<code>embstr</code>编码方式来保存。这种编码方式和<code>raw</code>一样，也是用SDS来保存，不同的是，在分配对象内存和<code>sdshdr</code>内存的时候是一次分配连续的空间（<code>createEmbeddedStringObject</code>），依次包含<code>redisObject</code>和<code>sdshdr</code>。好处是分配和销毁都只需要一次内存操作，缓存时也更有优势</li>
<li>可以用long double类型表示的浮点数也是作为字符串来保存的，编码为<code>raw</code>或<code>embstr</code>（<code>createStringObjectFromLongDouble</code>）。在某些针对浮点数的运算操作时，会先把保存的字符串转成浮点数运算，运算完再转成字符串保存</li>
</ul>
<h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>对<code>int</code>编码的字符串对象执行某些命令时，当修改后保存的不再是整数值时会转换成<code>raw</code>编码；redis中对于<code>embstr</code>编码的字符串对象不能进行修改，只读状态，执行修改命令时总会转成<code>raw</code>编码的字符串对象。</p>
<h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p>针对字符串对象的命令可参见<a href="https://redis.io/commands#string" target="_blank" rel="external">redis commands</a>，下表给出了各个命令在不同编码下的实现(<a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/t_string.c" target="_blank" rel="external">t_string.c</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:right"><code>int</code>编码</th>
<th style="text-align:right"><code>embstr</code>编码</th>
<th style="text-align:right"><code>raw</code>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>SET</code>/<code>SETNX</code>/<code>SETEX</code>/<code>PSETEX</code></td>
<td style="text-align:right">根据值选择相应编码</td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>GET</code></td>
<td style="text-align:right">拷贝对象的整数值，转成字符串（<code>ll2string</code>）返回</td>
<td style="text-align:right">直接返回</td>
<td style="text-align:right">直接返回</td>
</tr>
<tr>
<td style="text-align:center"><code>GETSET</code></td>
<td style="text-align:right">同<code>SET</code>+<code>GET</code></td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>SETRANGE</code></td>
<td style="text-align:right">转<code>raw</code>处理</td>
<td style="text-align:right">转<code>raw</code>处理</td>
<td style="text-align:right">设置字符串特定索引上的值，长度不够时扩展（<code>sdsgrowzero</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>GETRANGE</code></td>
<td style="text-align:right">拷贝对象的整数值，转成字符串（<code>ll2string</code>）返回指定索引上的值</td>
<td style="text-align:right">返回指定索引上的值</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>MGET</code></td>
<td style="text-align:right">遍历key，其他和<code>GET</code>类似</td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>MSET</code>/<code>MSETNX</code>/<code>MSETEX</code></td>
<td style="text-align:right">遍历key/value，其他和<code>SET</code>类似</td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>INCR</code>/<code>INCRBY</code>/<code>DECR</code>/<code>DECRBY</code></td>
<td style="text-align:right">调用<code>incrDecrCommand</code>，参数不同，整型或可以转整型时（<code>getLongLongFromObjectOrReply</code>）work，计算完按结果set</td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>INCRBYFLOAT</code></td>
<td style="text-align:right">整型转或字符串可以转long double时（<code>getLongDoubleFromObjectOrReply</code>）work，计算完按结果set（<code>embstr</code>或<code>raw</code>）</td>
<td style="text-align:right">同</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>APPEND</code></td>
<td style="text-align:right">转<code>raw</code>处理</td>
<td style="text-align:right">转<code>raw</code>处理</td>
<td style="text-align:right">调用<code>sdscatlen</code>追加字符串到末尾</td>
</tr>
<tr>
<td style="text-align:center"><code>STRLEN</code></td>
<td style="text-align:right">转字符串，返回字符串长度</td>
<td style="text-align:right">直接返回长度</td>
<td style="text-align:right">直接返回长度</td>
</tr>
</tbody>
</table>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是<code>ziplist</code>和<code>linkedlist</code>，不同的编码ptr指针指向不同的对象。其中，在<code>linkedlist</code>编码的列表对象里，<code>listNode</code>的value指针实际上是指向一个字符串对象（并非SDS的直接地址，后面几种对象嵌套字符串对象相同），字符串对象里保存的是列表节点的值。</p>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表满足以下两个条件时，使用<code>ziplist</code>编码，否则会转换成<code>linkedlist</code>编码（<code>listTypeTryConversion</code>）：</p>
<ul>
<li>保存的所有字符串元素的长度小于64字节（<code>list_max_ziplist_value</code>）</li>
<li>保存元素数量小于512个（<code>list_max_ziplist_entries</code>）</li>
</ul>
<h4 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h4><p>针对列表对象的命令可参见<a href="https://redis.io/commands#list" target="_blank" rel="external">redis commands</a>，下表给出了各个命令在不同编码下的实现(<a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/t_list.c" target="_blank" rel="external">t_list.c</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:right"><code>ziplist</code>编码</th>
<th style="text-align:right"><code>linkedlist</code>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>LPUSH</code>/<code>RPUSH</code>/<code>LPUSHX</code>/<code>RPUSHX</code></td>
<td style="text-align:right">调用<code>ziplistPush</code>，pos头节点或尾节点</td>
<td style="text-align:right">调用<code>listAddNodeHead</code>或<code>listAddNodeTail</code></td>
</tr>
<tr>
<td style="text-align:center"><code>LPOP</code>/<code>RPOP</code></td>
<td style="text-align:right"><code>ziplistIndex</code>定位头或尾，为弹出元素创建对象，调用<code>ziplistDelete</code>删除</td>
<td style="text-align:right">获取头节点或尾节点对象，调用<code>listDelNode</code>从链表删除</td>
</tr>
<tr>
<td style="text-align:center"><code>LLEN</code></td>
<td style="text-align:right">调用<code>ziplistLen</code></td>
<td style="text-align:right">调用<code>listLength</code></td>
</tr>
<tr>
<td style="text-align:center"><code>LINDEX</code></td>
<td style="text-align:right">调用<code>ziplistIndex</code></td>
<td style="text-align:right">调用<code>listIndex</code></td>
</tr>
<tr>
<td style="text-align:center"><code>LINSERT</code></td>
<td style="text-align:right">实现了列表的迭代器<code>listTypeInitIterator</code>，通过迭代器先查找插入位置，调用<code>ziplistInsert</code></td>
<td style="text-align:right">先通过迭代器查找插入位置，调用<code>listInsertNode</code></td>
</tr>
<tr>
<td style="text-align:center"><code>LRANGE</code></td>
<td style="text-align:right">调用<code>ziplistGet</code>和<code>ziplistNext</code>遍历</td>
<td style="text-align:right">遍历next</td>
</tr>
<tr>
<td style="text-align:center"><code>LREM</code></td>
<td style="text-align:right">通过迭代器遍历<code>listTypeNext</code>，比较<code>listTypeEqual</code>和删除<code>listTypeDelete</code>（<code>ziplistDelete</code>）</td>
<td style="text-align:right">同（<code>listDelNode</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>LSET</code></td>
<td style="text-align:right">查找<code>ziplistIndex</code>，删除<code>ziplistDelete</code>，插入<code>ziplistInsert</code></td>
<td style="text-align:right">查找<code>listIndex</code>，删除旧对象，指向新对象</td>
</tr>
<tr>
<td style="text-align:center"><code>LTRIM</code></td>
<td style="text-align:right">调用<code>ziplistDeleteRange</code>两次，删除左端元素和右端元素</td>
<td style="text-align:right">遍历两次调用<code>listDelNode</code></td>
</tr>
</tbody>
</table>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或<code>hashtable</code>。用<code>ziplist</code>保存哈希对象时，会将包含键的节点和值的节点依次加入表尾，所以哈希的键值对总是紧挨在一起存在压缩列表中。用字典保存哈希对象时，键值对的键和值都是以对象的形式保存在<code>dictEntry</code>中。</p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象满足以下两个条件时，使用<code>ziplist</code>编码，否则会转换成<code>hashtable</code>编码（<code>hashTypeTryConversion</code>）：</p>
<ul>
<li>保存的所有键值对的长度小于64字节（<code>hash_max_ziplist_value</code>）</li>
<li>保存键值对数量小于512个（<code>hash_max_ziplist_entries</code>）</li>
</ul>
<h4 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h4><p>针对哈希对象的命令可参见<a href="https://redis.io/commands#hash" target="_blank" rel="external">redis commands</a>，下表给出了各个命令在不同编码下的实现(<a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/t_hash.c" target="_blank" rel="external">t_hash.c</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:right"><code>ziplist</code>编码</th>
<th style="text-align:right"><code>hashtable</code>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>HSET</code>/<code>HMSET</code></td>
<td style="text-align:right">查找<code>ziplistFind</code>，找到的话删除旧值<code>ziplistDelete</code>，插入新值<code>ziplistInsert</code>，找不到的话添加键和值对象到尾部<code>ziplistPush</code></td>
<td style="text-align:right">调用<code>dictReplace</code>替换或者添加</td>
</tr>
<tr>
<td style="text-align:center"><code>HSETNX</code></td>
<td style="text-align:right"><code>HEXISTS</code> + <code>HSET</code></td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>HGET</code>/<code>HEXISTS</code>/<code>HMGET</code></td>
<td style="text-align:right">调用<code>hashTypeGetFromZiplist</code>，函数内调用<code>ziplistFind</code>查找</td>
<td style="text-align:right">调用<code>hashTypeGetFromHashTable</code>，函数内调用<code>dictFind</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HGETALL</code>/<code>HKEYS</code>/<code>HVALS</code></td>
<td style="text-align:right">实现了哈希的迭代器<code>hashTypeInitIterator</code>，通过迭代器迭代<code>hashTypeNext</code>获取</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>HDEL</code></td>
<td style="text-align:right">查找<code>ziplistFind</code>，删除<code>ziplistDelete</code></td>
<td style="text-align:right">调用<code>dictDelete</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HLEN</code></td>
<td style="text-align:right">调用<code>ziplistLen</code></td>
<td style="text-align:right">调用<code>dictSize</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HINCRBY</code>/<code>HINCRBYFLOAT</code></td>
<td style="text-align:right">查找，转long/long double，计算完set</td>
<td style="text-align:right">同</td>
</tr>
</tbody>
</table>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是<code>intset</code>或<code>hashtable</code>。<code>intset</code>编码使用整数集合作为底层实现，<code>hashtable</code>编码则使用字典作为底层实现，字典的键是一个字符串对象，作为集合的元素，值则全部设置为NULL。</p>
<h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象满足以下两个条件时，使用<code>intset</code>编码，否则会转换成<code>hashtable</code>编码（<code>setTypeConvert</code>）：</p>
<ul>
<li>保存的所有元素都是整数值</li>
<li>保存的元素数量小于512个（<code>set_max_intset_entries</code>）</li>
</ul>
<h4 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h4><p>针对集合对象的命令可参见<a href="https://redis.io/commands#set" target="_blank" rel="external">redis commands</a>，下表给出了各个命令在不同编码下的实现(<a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/t_set.c" target="_blank" rel="external">t_set.c</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:right"><code>intset</code>编码</th>
<th style="text-align:right"><code>hashtable</code>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>SADD</code></td>
<td style="text-align:right">检查<code>isObjectRepresentableAsLongLong</code>，可以的话调用<code>intsetAdd</code>，不行的话编码转换</td>
<td style="text-align:right">调用<code>dictAdd</code></td>
</tr>
<tr>
<td style="text-align:center"><code>SREM</code></td>
<td style="text-align:right">调用<code>intsetRemove</code></td>
<td style="text-align:right">调用<code>dictDelete</code></td>
</tr>
<tr>
<td style="text-align:center"><code>SCARD</code></td>
<td style="text-align:right">调用<code>intsetLen</code></td>
<td style="text-align:right">调用<code>dictSize</code></td>
</tr>
<tr>
<td style="text-align:center"><code>SISMEMBER</code></td>
<td style="text-align:right">调用<code>intsetFind</code></td>
<td style="text-align:right">调用<code>dictFind</code></td>
</tr>
<tr>
<td style="text-align:center"><code>SMEMBERS</code></td>
<td style="text-align:right">实现了集合的迭代器<code>setTypeIterator</code>，通过迭代器迭代获取<code>setTypeNext</code>(<code>intsetGet</code>)</td>
<td style="text-align:right">同（<code>dictNext</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>SRANDMEMBER</code>/<code>SPOP</code></td>
<td style="text-align:right">调用<code>intsetRandom</code></td>
<td style="text-align:right">调用<code>dictGetRandomKey</code></td>
</tr>
<tr>
<td style="text-align:center"><code>SMOVE</code></td>
<td style="text-align:right"><code>SREM</code> + <code>SADD</code></td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>SDIFF</code>/<code>SDIFFSTORE</code>/<code>SUNION</code>/<code>SUNIONSTORE</code></td>
<td style="text-align:right">调用<code>sunionDiffGenericCommand</code>，通过迭代器访问所有元素，union插入所有到结果集，diff两种算法：1. 遍历set[0]里的元素，比较这个元素是否在其他集合中再添加到结果集 2. 添加set[0]所有元素到结果集，遍历其他集合元素，挨个删除结果集</td>
<td style="text-align:right">同</td>
</tr>
<tr>
<td style="text-align:center"><code>SINTER</code>/<code>SINTERSTORE</code></td>
<td style="text-align:right">按集合大小排序，遍历最小集合，看元素是否存在其他集合中，都存在加到结果集</td>
<td style="text-align:right">同</td>
</tr>
</tbody>
</table>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合对象的编码可以是<code>ziplist</code>或<code>skiplist</code>。<code>ziplist</code>编码使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的节点保存，第一个是<code>member</code>，第二个是<code>score</code>，元素按照分值从小到大保存。<code>skiplist</code>编码则使用<code>zset</code>结构作为底层实现，<code>zset</code>结构同时包含一个字典和一个跳表。如下：<br><figure class="highlight c"><figcaption><span>redis.h/zset</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/redis.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zset &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 字典，键为成员，值为分值</span></div><div class="line">    <span class="comment">// 用于支持 O(1) 复杂度的按成员取分值操作</span></div><div class="line">    dict *dict;</div><div class="line"></div><div class="line">    <span class="comment">// 跳跃表，按分值排序成员</span></div><div class="line">    <span class="comment">// 用于支持平均复杂度为 O(log N) 的按分值定位成员操作</span></div><div class="line">    <span class="comment">// 以及范围操作</span></div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">&#125; zset;</div></pre></td></tr></table></figure><br><code>zset</code>通过dict可以在O(1)复杂度的情况下获取成员的分值（<code>ZSCORE</code>)，通过跳表可以在平均复杂度为 O(log N) 的情况下按分值定位成员（<code>ZRANGE</code>，<code>ZRANK</code>等）。所有元素并非保存两份在dict和跳表中，而是通过共享元素的成员和分值，不会造成内存浪费。</p>
<h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p>当有序集合对象满足以下两个条件时，使用<code>ziplist</code>编码，否则会转换成<code>skiplist</code>编码（<code>zsetConvert</code>相互转换）：</p>
<ul>
<li>保存的所有元素长度小于64字节（<code>zset_max_ziplist_value</code>)</li>
<li>保存的元素数量小于128个（<code>zset_max_ziplist_entries</code>）</li>
</ul>
<h4 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h4><p>针对有序集合对象的命令可参见<a href="https://redis.io/commands#sorted_set" target="_blank" rel="external">redis commands</a>，下表给出了各个命令在不同编码下的实现(<a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/t_zset.c" target="_blank" rel="external">t_zset.c</a>)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:right"><code>ziplist</code>编码</th>
<th style="text-align:right"><code>skiplist</code>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ZADD</code></td>
<td style="text-align:right">集合不存在创建<code>createZsetZiplistObject</code>，查找<code>zzlFind</code>，存在先删除<code>zzlDelete</code>，插入<code>zzlInsert</code></td>
<td style="text-align:right">不存在创建<code>createZsetObject</code>，查找<code>dictFind</code>，存在先删除跳表中元素<code>zslDelete</code>，插入<code>zslInsert</code>，更新字典值（存在更新指针，不存在添加<code>dictAdd</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>ZREM</code></td>
<td style="text-align:right">查找<code>zzlFind</code>，删除<code>zzlDelete</code></td>
<td style="text-align:right">查找<code>dictFind</code>，删除<code>zslDelete</code>+<code>dictDelete</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ZCARD</code></td>
<td style="text-align:right">调用<code>zzlLength</code>（<code>ziplistLen</code>/2)</td>
<td style="text-align:right">返回skiplist的length属性</td>
</tr>
<tr>
<td style="text-align:center"><code>ZCOUNT</code></td>
<td style="text-align:right">调用<code>zzlFirstInRange</code>获取范围内第一个元素，往后遍历<code>zzlNext</code>，超过范围跳出</td>
<td style="text-align:right">调用<code>zslFirstInRange</code>获取范围内第一个元素和最后一个元素，<code>zslGetRank</code>获取首尾rank相减+1</td>
</tr>
<tr>
<td style="text-align:center"><code>ZRANK</code>/<code>ZREVRANK</code></td>
<td style="text-align:right">从前往后遍历<code>zzlNext</code>，比较直到相同<code>ziplistCompare</code>（刚开始对这个函数理解有误，还以为是个bug）</td>
<td style="text-align:right">从字典获取score，调用<code>zslGetRank</code>得到rank</td>
</tr>
<tr>
<td style="text-align:center"><code>ZSCORE</code></td>
<td style="text-align:right">调用<code>zzlFind</code></td>
<td style="text-align:right">调用<code>dictFind</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ZRANGE</code>/<code>ZREVRANGE</code></td>
<td style="text-align:right">调用<code>ziplistIndex</code>定位到start位置元素，根据方向遍历<code>zzlPrev</code>或<code>zzlNext</code></td>
<td style="text-align:right">调用<code>zslGetElementByRank</code>定位到start位置元素，根据方向遍历（backward/forward）</td>
</tr>
<tr>
<td style="text-align:center"><code>ZLEXCOUNT</code></td>
<td style="text-align:right">调用<code>zslParseLexRange</code>parse range，调用<code>zzlFirstInLexRange</code>定位到开始位置，迭代<code>zzlNext</code>和判断<code>zzlLexValueLteMax</code>是否超出</td>
<td style="text-align:right">调用<code>zslParseLexRange</code>parse range，调用<code>zslFirstInLexRange</code>定位到开始位置，<code>zslLastInLexRange</code>定位到结束位置，调用<code>zslGetRank</code>获取两位置rank，相减</td>
</tr>
<tr>
<td style="text-align:center"><code>ZRANGEBYLEX</code>/<code>ZREVRANGEBYLEX</code></td>
<td style="text-align:right">和<code>ZLEXCOUNT</code>类似</td>
<td style="text-align:right">调用<code>zslParseLexRange</code>parse range，调用<code>zslFirstInLexRange</code>定位到开始位置，根据方向遍历和判断（<code>zslLexValueGteMin</code>/<code>zslLexValueLteMax</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>ZRANGEBYSCORE</code>/<code>ZREVRANGEBYSCORE</code></td>
<td style="text-align:right">调用<code>zslParseRange</code>parse range, 根据迭代方向定位开始位置<code>zzlFirstInRange</code>/<code>zzlLastInRange</code>，迭代<code>zzlPrev</code>/<code>zzlNext</code>和判断<code>zslValueGteMin</code>/<code>zslValueLteMax</code></td>
<td style="text-align:right">调用<code>zslParseRange</code>parse range, 根据迭代方向定位开始位置<code>zslFirstInRange</code>/<code>zslLastInRange</code>，迭代和判断<code>zslValueGteMin</code>/<code>zslValueLteMax</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ZREMRANGEBYLEX</code>/<code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code></td>
<td style="text-align:right">parse range，删除<code>zzlDeleteRangeByRank</code>/<code>zzlDeleteRangeByScore</code>/<code>zzlDeleteRangeByLex</code></td>
<td style="text-align:right">parse range，删除<code>zslDeleteRangeByRank</code>/<code>zslDeleteRangeByScore</code>/<code>zslDeleteRangeByLex</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ZUNIONSTORE</code>/<code>ZINTERSTORE</code></td>
<td style="text-align:right">实现了有序集合的迭代器<code>zuiInitIterator</code>，按集合大小排序，union迭代遍历<code>zuiNext</code>所有集合，插入，保存为<code>skiplist</code>编码；inter迭代遍历<code>zuiNext</code>src[0]，判断元素是否存在其他集合，计算插入，保存为<code>skiplist</code>编码</td>
<td style="text-align:right">同</td>
</tr>
</tbody>
</table>
<h3 id="类型检查和命令多态"><a href="#类型检查和命令多态" class="headerlink" title="类型检查和命令多态"></a>类型检查和命令多态</h3><p>redis用于操作键的命令基本分为两种，一种是通用的对于任何类型的键都适用（<code>DEL</code>，<code>EXPIRE</code>，<code>RENAME</code>，<code>TYPE</code>，<code>OBJECT</code>等）；另一种只适用于特定类型的。</p>
<p>类型检查是通过<code>redisObject</code>里的<code>type</code>属性来实现的，在执行一条命令之前，服务器会检查输入的键对象是否符合执行命令的类型<code>checkType</code>，是的话执行，否的话返回类型错误。</p>
<p>命令多态是根据<code>redisObject</code>里的<code>type</code>属性来判断和实现的，在执行命令的时候，根据<code>type</code>属性实现对不同底层编码进行操作。</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>redis通过引用计数来实现内存回收机制，信息保存在<code>redisObject</code>的<code>refCount</code>属性里。程序在执行过程中可以追踪对象的引用计数信息，在适当的时候释放对象进行内存回收：</p>
<ul>
<li>创建对象的时候，引用计数会被初始化为1</li>
<li>对象被新程序使用时，引用计数会加1<code>incrRefCount</code></li>
<li>对象不再被一个程序使用时，引用计数会减1<code>decrRefCount</code></li>
<li>对象引用计数为0时，对象所占内存会被释放</li>
</ul>
<p>其中还有一个api<code>resetRefCount</code>，作用是reset引用计数为0，但不释放对象，通常用于需要重新设置对象的引用计数值</p>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>通过引用计数还可以对对象进行共享，比如：A -&gt; 100，新建B也指向100，包含100的对象引用计数从1变成2，A和B共享了这个对象。</p>
<p>redis在初始化服务器的时候，会生成0~9999（<code>REDIS_SHARED_INTEGERS</code>）个字符串对象，当服务器需要用到0~9999范围内的对象时（直接使用或其他数据结构嵌套使用），就会使用这些共享对象，而不会新建。通过命令<code>OBJECT REFCOUNT</code>可以查看键的值对象的引用计数。</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p><code>redisObject</code>还有最后一个属性<code>lru</code>，记录了对象最后一次被命令程序访问的时间。通过命令<code>OBJECT IDLETIME</code>可以计算打印出指定键的空转时长。另外，如果服务器打开了<code>maxmemory</code>选项，且服务器用于回收内存的算法是<code>volatile-lru</code>或<code>allkeys-lru</code>时，当服务器内存数超过了<code>maxmemory</code>设置的上限值时，会优先释放空转时长较高的那部分键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面7章介绍了redis在底层用到的所有数据结构：&lt;code&gt;SDS&lt;/code&gt;，&lt;code&gt;双端链表&lt;/code&gt;，&lt;code&gt;字典&lt;/code&gt;，&lt;code&gt;skiplist&lt;/code&gt;，&lt;code&gt;整数集合&lt;/code&gt;，&lt;code&gt;ziplist&lt;/code&gt;。redis没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构实现了一个对象系统，包括以下五种类型：&lt;code&gt;字符串对象&lt;/code&gt;，&lt;code&gt;列表对象&lt;/code&gt;，&lt;code&gt;哈希对象&lt;/code&gt;，&lt;code&gt;集合对象&lt;/code&gt;和&lt;code&gt;有序集合对象&lt;/code&gt;。每种对象系统使用了至少一种前面的数据结构。对象系统带给redis的好处主要有以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过这五种不同类型的对象，redis在执行不同命令的时候可以对对象的类型进行检查，看该命令是否可以执行&lt;/li&gt;
&lt;li&gt;在不同的应用场景中，同一类对象可以针对不同的应用场景选择不同的数据结构实现，优化使用效率&lt;/li&gt;
&lt;li&gt;对象系统实现了基于引用技术的内存回收机制，对不再使用的对象进行回收。另外，通过引用技术可以实现对象共享机制，在适当的条件下达到对象共享，节约内存&lt;/li&gt;
&lt;li&gt;对象带有访问时间记录，可以计算数据库键的空转时长，在服务器启用&lt;code&gt;maxmemory&lt;/code&gt;功能时来确定删除优先级&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="对象" scheme="https://yezizp2012.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章7.压缩列表</title>
    <link href="https://yezizp2012.github.io/2017/02/04/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A07-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>https://yezizp2012.github.io/2017/02/04/Redis设计与实现笔记-章7-压缩列表/</id>
    <published>2017-02-04T04:25:07.000Z</published>
    <updated>2017-02-06T06:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表（ziplist）是哈希键和列表键的底层实现之一（当一个列表键只包含少量元素，不超过<code>list_max_ziplist_entries</code>的配置，并且元素要么是小整数或短字符串时），是为了节约内存，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（<code>entry</code>），每个节点可以保存一个字符数组或一个整数值。</p>
<a id="more"></a>
<h3 id="压缩列表的定义"><a href="#压缩列表的定义" class="headerlink" title="压缩列表的定义"></a>压缩列表的定义</h3><h4 id="ziplist结构"><a href="#ziplist结构" class="headerlink" title="ziplist结构"></a>ziplist结构</h4><p>ziplist的整体布局如下：</p>
<p><center><br>| zlbytes | zltail | zllen | entry1 | entry2 |entry3 | … | entryN | zlend |<br>|:——-:|:——:|:—–:|:——:|:——:|:—–:|:—:|:——:|:—–:|<br></center><br>不同组成部分的类型和用途如下：</p>
<ul>
<li><code>zlbytes</code>: uint32_t类型，占4字节，记录整个ziplist占用字节数，在对ziplist进行内存重分配或定位<code>zlend</code>时使用</li>
<li><code>zltail</code>: uint32_t类型，占4字节，记录尾节点距离ziplist起始地址的距离，即偏移量，用于定位尾节点位置</li>
<li><code>zllen</code>: uint16_t类型，占2字节，记录ziplist包含节点的数目，当值小于<code>UINT16_MAX</code>(65535)时为节点数目，当值等于<code>UINT16_MAX</code>时需要遍历ziplist才能计算</li>
<li><code>entryX</code>：节点类型，可以是字符数组也可以是整数值，长度由节点内容决定</li>
<li><code>zlend</code>：uint8_t类型，占1字节，特殊值0xFF(255)，用于标记ziplist末端</li>
</ul>
<h4 id="entry的定义"><a href="#entry的定义" class="headerlink" title="entry的定义"></a>entry的定义</h4><p>entry节点由以下三个部分构成：</p>
<p><center><strong>| previous_entry_length | encoding | content |</strong></center><br>不同组成部分的类型和用途如下：</p>
<ul>
<li><code>previous_entry_length</code>: 表示前一个节点的长度，以字节为单位，该属性可以为<code>1</code>个字节或<code>5</code>个字节，当前一个节点的长度小于254字节时该属性为1个字节（例：0x05），保存的即前一个节点的长度（5），当前一个节点的长度大于等于254字节时该属性为5个字节（例：0xFE00002766），其中第一个字节为默认值0xFE（254），后四个字节保存前一个节点的长度（0x00002766，10086）。通过该属性，我们可以从尾节点开始往前实现ziplist的遍历（当前指针向前偏移该属性即可）</li>
<li><code>encoding</code>: 记录content保存的数据的类型和长度，该属性可以为<code>1</code>字节、<code>2</code>字节和<code>5</code>字节长。当属性为1字节且最高位为11开始的表示整数，其他表示字节数组。具体内容如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:left">content属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11000000</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">int16_t类型的整数</td>
</tr>
<tr>
<td style="text-align:center">11010000</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">int32_t类型的整数</td>
</tr>
<tr>
<td style="text-align:center">11100000</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">int64_t类型的整数</td>
</tr>
<tr>
<td style="text-align:center">11110000</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">24位有符号整数</td>
</tr>
<tr>
<td style="text-align:center">11111110</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">8位有符号整数</td>
</tr>
<tr>
<td style="text-align:center">1111xxxx</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">该编码无content属性，xxxx位保存的是(1111xxxx &amp; 0x0f) - 1，范围为0~12</td>
</tr>
<tr>
<td style="text-align:center">00bbbbbb</td>
<td style="text-align:center">1字节</td>
<td style="text-align:left">长度小于等于63字节的字节数组</td>
</tr>
<tr>
<td style="text-align:center">01bbbbbb xxxxxxxx</td>
<td style="text-align:center">2字节</td>
<td style="text-align:left">长度小于等于16383字节的字节数组</td>
</tr>
<tr>
<td style="text-align:center">10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td style="text-align:center">5字节</td>
<td style="text-align:left">长度小于等于4294967295字节的字节数组，不包含_部分</td>
</tr>
</tbody>
</table>
<ul>
<li><code>content</code>: 保存节点的值，类型和长度由<code>encoding</code>决定</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>由<code>previous_entry_length</code>的定义可知，该属性记录了前一节点的长度，当ziplist中所有节点的长度均介于250-253之间时候，每个节点的<code>previous_entry_length</code>属性都是一个字节。当在头部插入一长度大于等于254的节点时，原来头部e1的节点<code>previous_entry_length</code>属性需要扩展到5节点，此时需要对ziplist执行空间重新分配，重新分配后e1的长度又大于等于254，e2也需要扩容，从而引起连锁更新。此时复杂度成为O(N^2)，同理删除长节点链表里某一短节点时等等，均会出现连锁更新（ps：当ziplist节点均介于254-257时插入短节点不会出现连锁更新，避免抖动直接用5字节存储了只需要1字节的长度编码<code>__ziplistCascadeUpdate</code>）。不过，这些情况出现的概率很低，所以更新的平均复杂度在O(N)。</p>
<h3 id="ziplist相关API"><a href="#ziplist相关API" class="headerlink" title="ziplist相关API"></a>ziplist相关API</h3><p>相关api定义在ziplist.h里，实现在ziplist.c，主要api如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">作用和代码逻辑</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ziplistNew</code></td>
<td style="text-align:left">创建新的压缩列表，为表头和表末端分配内存，初始化几个属性</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistPush</code></td>
<td style="text-align:left">添加新节点到ziplist的头部或尾部，根据where参数计算插入位置是头部还是尾部，调用<code>__ziplistInsert</code>：1. 获取插入位置前一个节点的长度 2. 尝试转换插入字符串为整数（<code>zipTryEncoding</code>）并计算插入节点所需字节长度（节点值长度+前置节点长度编码长度+当前节点值encoding长度）3. 插入新节点不在末端时，计算插入位置节点的前置节点长度编码长度字节和当前节点的长度编码长度字节大小差nextdiff（<code>zipPrevLenByteDiff</code>）来resize当前的ziplist（<code>ziplistResize</code>，不改变原有数据）4. 后移现有元素，将新元素的长度编码到后置节点，设置表尾迁移量，如果nextdiff不为0还需级联更新后续节点（<code>__ziplistCascadeUpdate</code>，计算前置节点长度编码所需字节和当前<code>previous_entry_length</code>长度，少则扩容继续更新，多或者够用即退出，连锁更新可能出现） 5. 写入新节点，设置新节点三个属性，更新ziplist的length</td>
<td style="text-align:center">O(N)，最坏情况O(N^2)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistInsert</code></td>
<td style="text-align:left">插入新节点到指定节点之后，<code>__ziplistInsert</code></td>
<td style="text-align:center">O(N)，最坏情况O(N^2)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistIndex</code></td>
<td style="text-align:left">返回给定索引上的节点，索引为正从头开始，计算节点占用字符累加进行遍历<code>zipRawEntryLength</code>，负从尾开始，根据前置节点长度累减进行遍历</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistFind</code></td>
<td style="text-align:left">查找并返回包含指定值的节点，skip参数表示隔skip个节点查找，ziplist encode其他结构时（如hash）使用</td>
<td style="text-align:center">查找值是整数时为O(N)，字节数组时为O(N^2)（compare为O(N)）</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistNext</code></td>
<td style="text-align:left">返回给定节点下一个节点，加<code>zipRawEntryLength</code>得到</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistPrev</code></td>
<td style="text-align:left">返回给定节点前一个节点，减去前置节点长度得到</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistGet</code></td>
<td style="text-align:left">返回给定节点保存的值，根据encoding返回值和是否成功</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistDelete</code></td>
<td style="text-align:left">删除给定节点，调用<code>__ziplistDelete</code>（删除给定节点后num个节点，传入num参数为1）：1. 计算被删除节点占用字节数，计算第一个删除节点的前置节点的长度编码所需字节和最后一个删除节点的后置节点first已有前置节点长度的编码所需字节长度差nextdiff 2. 更新first节点的前置节点长度编码，前移后续节点，resize和设置ziplist相关属性 3. nextdiff不为0时进行级联更新后续节点（<code>__ziplistCascadeUpdate</code>）</td>
<td style="text-align:center">O(N)，最坏情况O(N^2)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistDeleteRange</code></td>
<td style="text-align:left">删除连续几个节点，调用<code>__ziplistDelete</code></td>
<td style="text-align:center">O(N)，最坏情况O(N^2)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistBlobLen</code></td>
<td style="text-align:left">返回ziplist占用字节数，直接返回</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ziplistLen</code></td>
<td style="text-align:left">返回ziplist包含节点数量</td>
<td style="text-align:center">数量小于65535时为O(1)，否则遍历统计O(N)</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;压缩列表（ziplist）是哈希键和列表键的底层实现之一（当一个列表键只包含少量元素，不超过&lt;code&gt;list_max_ziplist_entries&lt;/code&gt;的配置，并且元素要么是小整数或短字符串时），是为了节约内存，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（&lt;code&gt;entry&lt;/code&gt;），每个节点可以保存一个字符数组或一个整数值。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="列表" scheme="https://yezizp2012.github.io/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章6.整数集合</title>
    <link href="https://yezizp2012.github.io/2017/01/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A06-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>https://yezizp2012.github.io/2017/01/19/Redis设计与实现笔记-章6-整数集合/</id>
    <published>2017-01-19T03:46:30.000Z</published>
    <updated>2017-02-04T09:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>整数集合（intset）是集合键的底层实现之一（当一个集合只包含整数值元素，并且元素数量不多时，不超过<code>set_max_intset_entries</code>的配置），可以保存<code>int16_t</code>，<code>int32_t</code>，<code>int64_t</code>的整数值且不会重复。</p>
<a id="more"></a>
<h3 id="intset的定义"><a href="#intset的定义" class="headerlink" title="intset的定义"></a>intset的定义</h3><figure class="highlight c"><figcaption><span>intset.h/intset</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/intset.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset &#123;    </div><div class="line">    <span class="comment">// 编码方式（INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64）</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;</div><div class="line">    <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line">    <span class="comment">// 保存元素的数组</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<ul>
<li>intset里用contents数组来保存元素，虽然是按照int8_t来定义的，但是元素的类型取决于encoding。三种encoding类型分别为<code>int16_t</code>，<code>int32_t</code>，<code>int64_t</code>的大小，所以contents数组的实际大小为encoding*length</li>
<li>各项元素在contents里面是按照从小到大的顺序保存的，当新增的元素类型比当前集合的编码长时，需要对集合进行升级，即将修改当前集合的编码方式并重新排列元素在contents数组里的位置并插入新的元素（所以任意时刻集合里保存的元素类型都是一样的，不存在不同类型存在同一集合中）</li>
</ul>
<h3 id="intset的升级"><a href="#intset的升级" class="headerlink" title="intset的升级"></a>intset的升级</h3><p>当新增的元素比当前编码的数据类型长时，需要进行升级（<code>intsetUpgradeAndAdd</code>）<br><figure class="highlight c"><figcaption><span>intset.c/intsetUpgradeAndAdd</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/intset.c" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 当前的编码方式</span></div><div class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line"></div><div class="line">    <span class="comment">// 新值所需的编码方式</span></div><div class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</div><div class="line"></div><div class="line">    <span class="comment">// 当前集合的元素数量</span></div><div class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</div><div class="line"></div><div class="line">    <span class="comment">// 根据 value 的值，决定是将它添加到底层数组的最前端还是最后端</span></div><div class="line">    <span class="comment">// 注意，因为 value 的编码比集合原有的其他元素的编码都要大</span></div><div class="line">    <span class="comment">// 所以 value 要么大于集合中的所有元素，要么小于集合中的所有元素</span></div><div class="line">    <span class="comment">// 因此，value 只能添加到底层数组的最前端或最后端</span></div><div class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* First set new encoding and resize */</span></div><div class="line">    <span class="comment">// 更新集合的编码方式</span></div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    <span class="comment">// 根据新编码对集合（的底层数组）进行空间调整</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></div><div class="line">     * Note that the "prepend" variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    <span class="comment">// 根据集合原来的编码方式，从底层数组中取出集合元素</span></div><div class="line">    <span class="comment">// 然后再将元素以新编码的方式添加到集合中</span></div><div class="line">    <span class="comment">// 当完成了这个步骤之后，集合中所有原有的元素就完成了从旧编码到新编码的转换</span></div><div class="line">    <span class="comment">// 因为新分配的空间都放在数组的后端，所以程序先从后端向前端移动元素</span></div><div class="line">    <span class="comment">// 举个例子，假设原来有 curenc 编码的三个元素，它们在数组中排列如下：</span></div><div class="line">    <span class="comment">// | x | y | z | </span></div><div class="line">    <span class="comment">// 当程序对数组进行重分配之后，数组就被扩容了（符号 ？ 表示未使用的内存）：</span></div><div class="line">    <span class="comment">// | x | y | z | ? |   ?   |   ?   |</span></div><div class="line">    <span class="comment">// 这时程序从数组后端开始，重新插入元素：</span></div><div class="line">    <span class="comment">// | x | y | z | ? |   z   |   ?   |</span></div><div class="line">    <span class="comment">// | x | y |   y   |   z   |   ?   |</span></div><div class="line">    <span class="comment">// |   x   |   y   |   z   |   ?   |</span></div><div class="line">    <span class="comment">// 最后，程序可以将新元素添加到最后 ？ 号标示的位置中：</span></div><div class="line">    <span class="comment">// |   x   |   y   |   z   |  new  |</span></div><div class="line">    <span class="comment">// 上面演示的是新元素比原来的所有元素都大的情况，也即是 prepend == 0</span></div><div class="line">    <span class="comment">// 当新元素比原来的所有元素都小时（prepend == 1），调整的过程如下：</span></div><div class="line">    <span class="comment">// | x | y | z | ? |   ?   |   ?   |</span></div><div class="line">    <span class="comment">// | x | y | z | ? |   ?   |   z   |</span></div><div class="line">    <span class="comment">// | x | y | z | ? |   y   |   z   |</span></div><div class="line">    <span class="comment">// | x | y |   x   |   y   |   z   |</span></div><div class="line">    <span class="comment">// 当添加新值时，原本的 | x | y | 的数据将被新值代替</span></div><div class="line">    <span class="comment">// |  new  |   x   |   y   |   z   |</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="keyword">while</span>(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></div><div class="line">    <span class="comment">// 设置新值，根据 prepend 的值来决定是添加到数组头还是数组尾</span></div><div class="line">    <span class="keyword">if</span> (prepend)</div><div class="line">        _intsetSet(is,<span class="number">0</span>,value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line"></div><div class="line">    <span class="comment">// 更新整数集合的元素数量</span></div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>升级的好处: 灵活，不需要关注int类型，统一处理；节约内存，相比于按<code>int64_t</code>来兼容所有int类型。</p>
<h3 id="整数集合相关API"><a href="#整数集合相关API" class="headerlink" title="整数集合相关API"></a>整数集合相关API</h3><p>相关api定义在intset.h里，实现在intset.c，主要api如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">作用和代码逻辑</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>intsetNew</code></td>
<td style="text-align:left">创建新的整数集合，分配内存，设置编码默认为<code>INTSET_ENC_INT16</code></td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetAdd</code></td>
<td style="text-align:left">将给定元素添加到整数集合：1. 获取插入值的编码长度，如果大于集合编码长度，进行升级插入 2. 如果插入值已经存在<code>intsetSearch</code>，标记success为0并返回 3. 分配内存，将插入位置pos后的元素后移<code>intsetMoveTail</code>，设置pos位置上的值<code>_intsetSet</code>，并更新length属性</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetRemove</code></td>
<td style="text-align:left">删除整数集合中给定元素：1. 获取删除值的编码长度，如果大于集合编码长度或查找给定元素不存在<code>intsetSearch</code>时，返回并设置success为0 2. 将查找位置pos的元素前移<code>intsetMoveTail</code>，resize<code>intsetResize</code>和设置length属性</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetFind</code></td>
<td style="text-align:left">查找指定元素是否存在，根据查找元素编码长度和二分查找<code>intsetSearch</code></td>
<td style="text-align:center">O(logN)</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetRandom</code></td>
<td style="text-align:left">从集合中随机返回一个元素</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetGet</code></td>
<td style="text-align:left">返回给定pos上的元素</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetLen</code></td>
<td style="text-align:left">返回集合长度</td>
<td style="text-align:center">O(1)，返回length属性</td>
</tr>
<tr>
<td style="text-align:center"><code>intsetBlobLen</code></td>
<td style="text-align:left">返回集合占用字节数，sizeof(intset)+length*encoding</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整数集合（intset）是集合键的底层实现之一（当一个集合只包含整数值元素，并且元素数量不多时，不超过&lt;code&gt;set_max_intset_entries&lt;/code&gt;的配置），可以保存&lt;code&gt;int16_t&lt;/code&gt;，&lt;code&gt;int32_t&lt;/code&gt;，&lt;code&gt;int64_t&lt;/code&gt;的整数值且不会重复。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="集合" scheme="https://yezizp2012.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章5.跳表</title>
    <link href="https://yezizp2012.github.io/2017/01/11/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A05-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://yezizp2012.github.io/2017/01/11/Redis设计与实现笔记-章5-跳表/</id>
    <published>2017-01-11T03:46:53.000Z</published>
    <updated>2017-01-12T04:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>跳表（<a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="external">skiplist</a>）是一种有序的数据结构，通过在每个节点中维护多个指向其他节点的指针来实现快速查找。实现简单，平均复杂度为O（logN），效率可媲美平衡树。Redis使用跳表来作为有序集合键的底层实现之一（有序集合包含元素比较多或元素是比较长的字符串时）和集群节点的内部数据结构。</p>
<a id="more"></a>
<h3 id="跳表的实现"><a href="#跳表的实现" class="headerlink" title="跳表的实现"></a>跳表的实现</h3><p><center><img src="zskiplist.png" alt="zskiplist"></center><br><figure class="highlight c"><figcaption><span>redis.h/zskiplistNode,zskiplist</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/redis.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;<span class="comment">// 跳表节点</span></div><div class="line">    robj *obj;<span class="comment">// 成员对象</span></div><div class="line">    <span class="keyword">double</span> score;<span class="comment">// 分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;<span class="comment">// 后退指针，指向前一个节点，从尾往头遍历可用</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;<span class="comment">// 层</span></div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;<span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">// 跨度，前进指针和当前指针的距离</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;<span class="comment">// 跳表</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;<span class="comment">// 头尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">// 表中节点的数量（不包含头节点，头节点不含数据）</span></div><div class="line">    <span class="keyword">int</span> level;<span class="comment">// 表中层数最大的节点的层数（不包含头结点）</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure></p>
<ol>
<li>由图和定义可知，跳表level数组可以包含多个指向后续节点的指针，通过这些指针可以加速访问其他节点。</li>
<li>当每次创建一个新的跳表节点时，程序会根据幂次定律（power law，越大的数出现概率越小）随机生成一个介于<code>1~32</code>的值作为节点level数组的大小，即节点层的高度。</li>
<li>跨度span可以用来计算查找的节点的rank，在查找过程中，访问过的所有层span的和即查找节点的rank。另外，从头节点开始，依次访问level数组中span为1(L1/level[0])的前进指针直到结束，可以顺序遍历到所有节点。</li>
<li>后退指针可以从tail开始顺序遍历到header。</li>
<li>跳表中所有节点按照score从小到大排序（score相同的节点按照obj的字典序排序），obj是一个成员对象，指向一个字符串对象（SDS）。</li>
<li>跳表可以在O(1)时间内获取头尾节点、跳表长度。</li>
</ol>
<h3 id="跳表相关API"><a href="#跳表相关API" class="headerlink" title="跳表相关API"></a>跳表相关API</h3><p>跳表相关的函数定义在redis.h中，函数实现在t_zset.c里面，主要的函数及说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">作用和代码逻辑</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>zslCreate/zslCreateNode</code></td>
<td style="text-align:center">创建新的跳表(包括head节点，层数为ZSKIPLIST_MAXLEVEL-32)/跳表节点</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>zslFree/zslFreeNode</code></td>
<td style="text-align:center">释放给定跳表，含所有跳表节点（释放过程中减少obj的引用计数，引用计数为0时会被自动释放<code>decrRefCount</code>）</td>
<td style="text-align:center">O(N)，N为跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslInsert</code></td>
<td style="text-align:center">插入节点到跳表：1. 查找节点插入位置，自上而下查找比较，并记录每层插入位置的pre节点及其rank，供后面更新使用 2. <code>zslRandomLevel</code>随机一个层高给当前节点，如果随机的newlevel大于当前最大level，更新头节点level~newlevel的level数组和跳表level属性 3. 创建新节点，并更新新节点level数组pre的指针和span、level~newlevel的span，新节点的backward</td>
<td style="text-align:center">平均O(logN)，最坏O(N)，N为跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslDelete</code></td>
<td style="text-align:center">删除指定节点： 1. 查找指定节点位置，自上而下查找比较，并记录每层查找位置的pre节点，供后面更新使用 2. 更新每层查找的pre节点的forward和span、删除节点后一个节点的backward 3.更新跳表length属性并删除节点</td>
<td style="text-align:center">平均O(logN)，最坏O(N)，N为跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslGetRank</code></td>
<td style="text-align:center">返回节点在跳表中的rank：逻辑同查找，查找过程中span加起来</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>zslGetElementByRank</code></td>
<td style="text-align:center">返回给定rank的节点：自上而下，和查找类似，仅判断逻辑不一样</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>zslIsInRange</code></td>
<td style="text-align:center">判断给定range是否在跳表范围内</td>
<td style="text-align:center">O(1)，直接比较(header.score, tail.score)</td>
</tr>
<tr>
<td style="text-align:center"><code>zslFirstInRange</code></td>
<td style="text-align:center">找出符合给定range在跳表里的第一个节点：同查找类似，判断逻辑不同，先调用<code>zslIsInRange</code></td>
<td style="text-align:center">平均O(logN)，最坏O(N)，N为跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslLastInRange</code></td>
<td style="text-align:center">找出符合给定range在跳表里的最后一个节点：同查找类似，判断逻辑不同，先调用<code>zslIsInRange</code></td>
<td style="text-align:center">平均O(logN)，最坏O(N)，N为跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslDeleteRangeByScore</code></td>
<td style="text-align:center">删除score在给定range的所有节点：同删除，定位pre的判断逻辑不一样</td>
<td style="text-align:center">O(N)，N跳表长度</td>
</tr>
<tr>
<td style="text-align:center"><code>zslDeleteRangeByRank</code></td>
<td style="text-align:center">删除rank在给定range的所有节点：同删除，定位pre的判断逻辑不一样</td>
<td style="text-align:center">O(N)，N跳表长度</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跳表（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8&quot;&gt;skiplist&lt;/a&gt;）是一种有序的数据结构，通过在每个节点中维护多个指向其他节点的指针来实现快速查找。实现简单，平均复杂度为O（logN），效率可媲美平衡树。Redis使用跳表来作为有序集合键的底层实现之一（有序集合包含元素比较多或元素是比较长的字符串时）和集群节点的内部数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="跳表" scheme="https://yezizp2012.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章4.字典</title>
    <link href="https://yezizp2012.github.io/2017/01/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A04-%E5%AD%97%E5%85%B8/"/>
    <id>https://yezizp2012.github.io/2017/01/09/Redis设计与实现笔记-章4-字典/</id>
    <published>2017-01-09T08:35:21.000Z</published>
    <updated>2017-01-09T10:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>字典在Redis里应用十分广泛，比如最重要的作为kv的数据库就是用字典来实现的。字典也是hash键的底层实现之一（当hash键包含的键值对较多，或者键值对中元素都是比较长时），另外很多其他的功能也用到了字典。</p>
<a id="more"></a>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用哈希表作为底层实现，每个哈希表可以有多个哈希表节点，每个节点保存了字典中的一个键值对。整个关联结构见图：<br><img src="http://note.huangz.me/_images/relationship.png"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="字典，字典值类型，迭代器的定义"><a href="#字典，字典值类型，迭代器的定义" class="headerlink" title="字典，字典值类型，迭代器的定义"></a>字典，字典值类型，迭代器的定义</h5><figure class="highlight c"><figcaption><span>dict.h/dict</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</div><div class="line">    <span class="comment">// 计算哈希值的函数</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line">    <span class="comment">// 复制键的函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line">    <span class="comment">// 复制值的函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line">    <span class="comment">// 对比键的函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line">    <span class="comment">// 销毁键的函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line">    <span class="comment">// 销毁值的函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line">&#125; dictType;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</div><div class="line">    dict *d;<span class="comment">// 被迭代的字典</span></div><div class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></div><div class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></div><div class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></div><div class="line">    <span class="keyword">int</span> table, index, safe;</div><div class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></div><div class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></div><div class="line">    <span class="comment">//             因为在安全迭代器运作时， entry 所指向的节点可能会被修改，</span></div><div class="line">    <span class="comment">//             所以需要一个额外的指针来保存下一节点的位置，</span></div><div class="line">    <span class="comment">//             从而防止指针丢失</span></div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">/* unsafe iterator fingerprint for misuse detection */</span></div><div class="line">&#125; dictIterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;<span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 私有数据，保存需要传递给特定类型特定函数的可选参数</span></div><div class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// 两个哈希表，实现渐进式rehash</span></div><div class="line">    <span class="keyword">int</span> rehashidx;<span class="comment">// 不在rehashing时为-1，否则为rehashing进度</span></div><div class="line">    <span class="keyword">int</span> iterators;<span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<h5 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h5><figure class="highlight c"><figcaption><span>dict.h/dictht</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;    </div><div class="line">	<span class="comment">// 哈希表数组，保存哈希表节点</span></div><div class="line">	dictEntry **table;</div><div class="line">	<span class="comment">// 哈希表大小，即table大小</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;	    </div><div class="line">	<span class="comment">// 哈希表大小掩码，和哈希值决定键放置到table哪个index</span></div><div class="line">	<span class="comment">// 总是等于 size - 1</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;	</div><div class="line">	<span class="comment">// 该哈希表已有节点的数量</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> used;</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<h5 id="哈希表节点的定义"><a href="#哈希表节点的定义" class="headerlink" title="哈希表节点的定义"></a>哈希表节点的定义</h5><figure class="highlight c"><figcaption><span>dict.h/dictht</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;  </div><div class="line">    <span class="keyword">void</span> *key;<span class="comment">//键</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">    &#125; v;<span class="comment">//值</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;<span class="comment">//指向下个哈希表节点，形成链表，解决冲突</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>用给定的字典类型和数据创建字典，并初始化字典各项属性。<br><figure class="highlight c"><figcaption><span>dict.c/dictCreate</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.c" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建</span></div><div class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span> </span></div><div class="line">&#123;</div><div class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</div><div class="line">    _dictInit(d,type,privDataPtr);</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type, <span class="keyword">void</span> *privDataPtr)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 初始化两个哈希表的各项属性值</span></div><div class="line">    <span class="comment">// 但暂时还不分配内存给哈希表数组</span></div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</div><div class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">    <span class="comment">// 设置类型特定函数</span></div><div class="line">    d-&gt;type = type;</div><div class="line">    <span class="comment">// 设置私有数据</span></div><div class="line">    d-&gt;privdata = privDataPtr;</div><div class="line">    <span class="comment">// 设置哈希表 rehash 状态</span></div><div class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">    <span class="comment">// 设置字典的安全迭代器数量</span></div><div class="line">    d-&gt;iterators = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"><span class="comment">//重置或初始化哈希表的各项属性</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</div><div class="line">&#123;</div><div class="line">    ht-&gt;table = <span class="literal">NULL</span>;</div><div class="line">    ht-&gt;size = <span class="number">0</span>;</div><div class="line">    ht-&gt;sizemask = <span class="number">0</span>;</div><div class="line">    ht-&gt;used = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>新加一个键值对到字典的时候，需要根据key来计算出哈希值，然后通过哈希值计算出索引值，再讲键值对的哈希表节点放到哈希表数组的指定索引上。<br><code>hash = dict-&gt;type-&gt;hashFunction(key);</code><br><code>index = hash &amp; dict-&gt;ht[x].sizemask;//x为0 or 1</code><br>Redis使用的hash算法是<a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="external">Murmurhash</a>的Murmurhash2版本，对于输入的键有规律的仍可以给出很好的随机分布，计算速度也很快。Redis实现见函数<code>dictGenHashFunction</code>。<br>解决键冲突的方法根据dictEntry的定义可以看出，Redis使用了链地址法来解决，即相同index的key节点用单向链表链接起来。基于新增加的键值对被访问的概率越高，redis将新添加的节点插入到链表head位置。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>由<code>_dictReset</code>函数可以知道，字典被创建的时候并未分配内存，只有当首次向字典里加入元素的时候，内存才真正被分配（<code>dictAdd</code>）。<br><figure class="highlight c"><figcaption><span>dict.c/dictAdd</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.c" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></div><div class="line">&#123;</div><div class="line">    dictEntry *entry = dictAddRaw(d,key);<span class="comment">//尝试添加键</span></div><div class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;<span class="comment">//键已经存在，返回失败</span></div><div class="line">    dictSetVal(d, entry, val);<span class="comment">//不存在，设置val</span></div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//pre code ......</span></div><div class="line"></div><div class="line">    <span class="comment">// 计算键在哈希表中的索引值</span></div><div class="line">    <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></div><div class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//after code, 分配空间给key，插入节点到哈希表数组，返回entry ......</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//pre code ......</span></div><div class="line">	 </div><div class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)<span class="comment">//是否需要扩展</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//after code,计算key的哈希值-&gt;索引值，遍历索引所在的链表看是否存在，</span></div><div class="line">    <span class="comment">//存在返回-1，否则返回索引值 ......</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//pre code ...</span></div><div class="line">    </div><div class="line">    <span class="comment">//第一次添加元素时</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 一下两个条件之一为真时，对字典进行扩展</span></div><div class="line">    <span class="comment">// 1）字典已使用节点数和字典大小之间的比率接近 1：1</span></div><div class="line">    <span class="comment">//    并且 dict_can_resize 为真</span></div><div class="line">    <span class="comment">// 2）已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 新哈希表的大小至少是目前已使用节点数的两倍，</span></div><div class="line">        <span class="comment">// 在dictExpand里实际扩展的大小是第一个大于传入参数的pow(2, X)</span></div><div class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>所有pre code基本上是变量申明，rehashing状态check和操作等，<code>dictExpand</code>主要是给哈希表数组扩展容量，包括rehashing状态的检查。</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>rehash操作主要是为了保证哈希表的负载均衡，当哈希表保存的键值对数量在过多和过少时进行相应的扩容和减容。rehash的操作work on哈希表ht[1]，rehash操作的状态由字典的属性rehashidx表示。</p>
<ol>
<li>为ht[1]分配空间，分配的空间大小由扩容或减容的操作和ht[0].used属性来决定：<ul>
<li>扩容的话，大小为第一个大于ht[0].used*2的pow(2, X)</li>
<li>减容的话，大小为第一个大于ht[1].used的pow(2, X)</li>
</ul>
</li>
<li>将ht[0]上面的所有键值对rehash到ht[1]上面</li>
<li>等rehash操作完毕后，释放ht[0]，将字典的ht[0]指向ht[1]，ht[1]新建一个空白的哈希表。</li>
</ol>
<p>rehash自动触发的几个条件（负载因子为节点数量/哈希表大小）：</p>
<ol>
<li>服务器没有执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令时，哈希表的负载因子大于等于1，执行扩展操作</li>
<li>服务器执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令时，哈希表的负载因子大于等于5，执行扩展操作</li>
<li>哈希表的负载因子小于0.1时，执行减容操作</li>
</ol>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>哈希表的rehash操作不是一次性、集中式的操作，除了服务器长时间没有命令执行，主动调用rehash（<code>dictRehashMilliseconds</code>）以外，还有另一种方式：渐进式rehash，操作的详细步骤如下：</p>
<ol>
<li>为ht[1]分配空间</li>
<li>rehashidx设置为0，表示rehash正式开始</li>
<li>rehash期间，所有增删改查的操作请求除了正常服务外，执行单步rehash（<code>_dictRehashStep</code>），单步rehash操作会rehash一条index的链表，同时rehashidx+1，下次rehash的时候就从rehashidx开始</li>
<li>当ht[0]所有键值对被rehash到ht[1]的时候，rehashidx重置为-1，完成</li>
</ol>
<p>渐进式rehash采用分治的思想把rehash的操作平摊到服务器请求上，避免集中式操作带来的庞大计算量。另外，在渐进式rehash执行国过程中，增删改查的操作会work在两张表上，新增的话会进到ht[1]等，保证ht[0]只减不增。</p>
<h3 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h3><p>字典的主要API包括了基本的字典操作:<br><code>dictCreate</code>，<code>dictAdd</code>，<code>dictReplace</code>，<code>dictFetchValue</code>，<code>dictGetRandomKey</code>，<code>dictDelete</code>，<code>dictRelease</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典在Redis里应用十分广泛，比如最重要的作为kv的数据库就是用字典来实现的。字典也是hash键的底层实现之一（当hash键包含的键值对较多，或者键值对中元素都是比较长时），另外很多其他的功能也用到了字典。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="字典" scheme="https://yezizp2012.github.io/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章3.链表</title>
    <link href="https://yezizp2012.github.io/2017/01/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A03-%E9%93%BE%E8%A1%A8/"/>
    <id>https://yezizp2012.github.io/2017/01/06/Redis设计与实现笔记-章3-链表/</id>
    <published>2017-01-06T06:35:09.000Z</published>
    <updated>2017-01-06T08:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis用C实现了链表，应用场景包括list（元素很多或包含元素都是较长字符串时），发布和订阅，慢查询，监视器等，另外客户端状态信息，客户端输出缓冲区都是用链表来保存。</p>
<a id="more"></a>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight c"><figcaption><span>adlist.h/listNode,list</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/adlist.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev;<span class="comment">//前一个节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next;<span class="comment">//后一个节点</span></div><div class="line">    <span class="keyword">void</span> *value;</div><div class="line">&#125; listNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    <span class="comment">// 当前迭代到的节点</span></div><div class="line">    listNode *next;</div><div class="line">    <span class="comment">// 迭代的方向</span></div><div class="line">    <span class="keyword">int</span> direction;</div><div class="line">&#125; listIter; <span class="comment">//链表迭代器</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;<span class="comment">//头节点</span></div><div class="line">    listNode *tail;<span class="comment">//尾节点</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">// 节点值复制函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);<span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;<span class="comment">// 链表所包含的节点数量</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<p>从实现上来看，Redis实现了一个双端链表，并保存了列表的长度和头尾节点指针。另外，节点的value类型为void*，加上提供<code>listSetDupMethod</code>，<code>listSetFreeMethod</code>，<code>listSetMatchMethod</code>接口实现保存不同类型的值（多态）。</p>
<h3 id="API和宏定义"><a href="#API和宏定义" class="headerlink" title="API和宏定义"></a>API和宏定义</h3><p>针对双端链表的API，包含链表基本操作和链表迭代相关的接口<br><figure class="highlight c"><figcaption><span>adlist.h/api</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/adlist.c" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建链表</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;<span class="comment">//释放链表</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;<span class="comment">//添加到head</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;<span class="comment">//添加到tail</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;<span class="comment">//插入节点，after为0插入到之前，1为之后</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;<span class="comment">//删除节点</span></div><div class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;<span class="comment">//创建迭代器，direction:AL_START_HEAD, AL_START_TAIL</span></div><div class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;<span class="comment">//获取下一个节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;<span class="comment">//释放迭代器</span></div><div class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;<span class="comment">//复制链表</span></div><div class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;<span class="comment">//查找key，通过match查找，未设置按照key == value</span></div><div class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;<span class="comment">//返回index位置的节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;<span class="comment">//设置迭代器方向为AL_START_HEAD</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;<span class="comment">//设置迭代器方向为AL_START_TAIL</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;<span class="comment">//取tail节点放置到头部，仅在处理客户端时使用（clientsCron）</span></div></pre></td></tr></table></figure><br>方便链表操作的宏定义<br><figure class="highlight c"><figcaption><span>adlist.h/#define</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/adlist.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，链表实现比较简单，提供了一些针对链表典型的基本操作（增删改查等）的API和宏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis用C实现了链表，应用场景包括list（元素很多或包含元素都是较长字符串时），发布和订阅，慢查询，监视器等，另外客户端状态信息，客户端输出缓冲区都是用链表来保存。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="链表" scheme="https://yezizp2012.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章2.简单动态字符串</title>
    <link href="https://yezizp2012.github.io/2017/01/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A02-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://yezizp2012.github.io/2017/01/05/Redis设计与实现笔记-章2-简单动态字符串/</id>
    <published>2017-01-05T06:35:09.000Z</published>
    <updated>2017-01-06T03:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis实现了一种简单动态字符串（simple dynamic string, SDS）来作为默认的字符串表示，代替了C语言里传统的字符串。C语言里传统的字符串仅仅作为const string使用，如打印日志时使用的message。</p>
<a id="more"></a>
<h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><figure class="highlight c"><figcaption><span>sds.h/sdshdr</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/sds.h" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">	<span class="keyword">int</span> len; <span class="comment">//记录buf已使用数量</span></div><div class="line">	<span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//未使用数量</span></div><div class="line">	<span class="keyword">char</span> buf[];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据SDS的定义我们知道，相比于传统的字符串，sdshdr额外存储了len和free两个字段。why？</p>
<ul>
<li>get len in O(1)</li>
<li>avoid buffer overflow，避免缓冲区溢出，SDS修改之前会check，不够时会扩展buf的空间</li>
<li>减少修改字符串带来的内存重分配，SDS会通过空间预分配和惰性空间释放来优化字符串的修改<ol>
<li>空间预分配（<code>sdsMakeRoomFor</code>, then <code>sdsIncrLen</code>），如果空余空间足够的话不予分配；所需长度（addlen+len）小于SDS_MAX_PREALLOC（1M）时，分配长度为所需长度double；所需长度大于等于SDS_MAX_PREALLOC时，分配长度为所需长度+SDS_MAX_PREALLOC。通过预分配可以减少分配次数。 <figure class="highlight c"><figcaption><span>sds.c</span><a href="https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/sds.c" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line"></div><div class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line"></div><div class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line"></div><div class="line">    <span class="comment">// s 最少需要的长度</span></div><div class="line">    newlen = (len+addlen);</div><div class="line"></div><div class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></div><div class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line">I</div><div class="line">    <span class="comment">// 内存不足，分配失败，返回</span></div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新 sds 的空余长度</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line"></div><div class="line">    <span class="comment">// 返回 sds</span></div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>惰性空间释放，优化SDS字符串缩短操作，不会真的释放空间，而是通过更新free和len字段记录空间使用情况。另外，SDS还提供API真正释放未使用的空间（<code>sdsRemoveFreeSpace</code>），不用担心内存浪费。</li>
</ol>
</li>
<li>二进制安全，C里面字符串里面不能包含空格，对于空格会认为是字符串的结束。SDS里面API读取数据是以二进制的形式来处理的，字符长度是通过len来获取而不是通过结束字符，所以SDR可以保存任意格式的二进制数据，图片，音频，压缩文件等。</li>
<li>兼容C字符串函数，work on buf字段 using <code>string.h</code><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">C字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度的复杂度为 O(N) 。</td>
<td style="text-align:center">获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出。</td>
<td style="text-align:center">API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度 N 次必然需要执行 N 次内存重分配。</td>
<td style="text-align:center">修改字符串长度 N 次最多需要执行 N 次内存重分配。</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据。</td>
<td style="text-align:center">可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td style="text-align:center">可以使用所有 <string.h> 库中的函数。</string.h></td>
<td style="text-align:center">可以使用一部分 <string.h> 库中的函数。</string.h></td>
</tr>
</tbody>
</table>
<h3 id="SDS-主要操作API"><a href="#SDS-主要操作API" class="headerlink" title="SDS 主要操作API"></a>SDS 主要操作API</h3><table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>sdsnew</code></td>
<td style="text-align:center">创建包含给定字符串的SDS</td>
<td style="text-align:center">O(N)，N为字符串长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsempty</code></td>
<td style="text-align:center">创建空字符串的SDS</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsfree</code></td>
<td style="text-align:center">释放给定的SDS</td>
<td style="text-align:center">O(N)，N为释放SDS字符串长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdslen</code></td>
<td style="text-align:center">返回给定SDS已使用空间字节数</td>
<td style="text-align:center">O(1)，直接读len字段</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsavail</code></td>
<td style="text-align:center">返回给定SDS可用空间字节数</td>
<td style="text-align:center">O(1)，直接读free字段</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsdup</code></td>
<td style="text-align:center">创建给定SDS的副本，copy</td>
<td style="text-align:center">O(N)，N为给定SDS长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsclear</code></td>
<td style="text-align:center">清空SDS内容</td>
<td style="text-align:center">O(1)，惰性释放</td>
</tr>
<tr>
<td style="text-align:center"><code>sdscat</code></td>
<td style="text-align:center">拼接给定字符串到SDS末尾</td>
<td style="text-align:center">O(N)，N为给定字符串长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdscatsds</code></td>
<td style="text-align:center">拼接给定SDS到SDS末尾</td>
<td style="text-align:center">O(N)，N为给定SDS长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdscpy</code></td>
<td style="text-align:center">将给定字符串复制到SDS里面，覆盖</td>
<td style="text-align:center">O(N)，N为字符串长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsgrowzero</code></td>
<td style="text-align:center">用空字符串扩充SDS到指定长度</td>
<td style="text-align:center">O(N)，N为新增长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdsrange</code></td>
<td style="text-align:center">保留SDS给定区间的数据，清除区间外的数据</td>
<td style="text-align:center">O(N)，N为保留区间长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdstrim</code></td>
<td style="text-align:center">去除SDS两端出现在给定字符串内的字符</td>
<td style="text-align:center">O(M*N)，M为SDS长度，N为字符串长度</td>
</tr>
<tr>
<td style="text-align:center"><code>sdscmp</code></td>
<td style="text-align:center">对比两个SDS是否相同</td>
<td style="text-align:center">O(N)，N为两个SDS中较短的一个</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis实现了一种简单动态字符串（simple dynamic string, SDS）来作为默认的字符串表示，代替了C语言里传统的字符串。C语言里传统的字符串仅仅作为const string使用，如打印日志时使用的message。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://yezizp2012.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现笔记-章1.引言</title>
    <link href="https://yezizp2012.github.io/2017/01/04/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E7%AB%A01.%E5%BC%95%E8%A8%80/"/>
    <id>https://yezizp2012.github.io/2017/01/04/Redis设计与实现笔记-章1.引言/</id>
    <published>2017-01-04T08:57:44.000Z</published>
    <updated>2017-01-06T09:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>我手上这本<a href="http://redisbook.com/" target="_blank" rel="external">Redis设计与实现</a>是基于Redis 3.0的开发版，主要包括四个大的部分：<code>数据结构与对象</code>，<code>单机数据库的实现</code>，<code>多机数据库的实现</code>，<code>独立功能的实现</code>。在阅读这本书的时候，另外参考了作者<br>黄建宏的<a href="http://note.huangz.me/storage/redis_code_analysis/index.html" target="_blank" rel="external">Redis源码分析</a>和<a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="external">github</a>，感谢。<br><a id="more"></a></p>
<h3 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h3><p>Redis是kv的内存数据库，每个key和value都是object，key是<strong>string</strong>类型，value可以是<strong>string，list，hash，set，sorted set</strong>五个类型里面之一。这部分分别介绍这五种数据结构的底层实现及性能。</p>
<h3 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h3><p>介绍单机数据库的实现方法，包括如何保存kv，过期时间处理，持久化，事件，客户端实现，命令的解析处理等。</p>
<h3 id="多机数据库的实现"><a href="#多机数据库的实现" class="headerlink" title="多机数据库的实现"></a>多机数据库的实现</h3><p>主要涉及Redis的复制，Sentinel，Cluster三个多机功能的实现。</p>
<h3 id="独立功能实现"><a href="#独立功能实现" class="headerlink" title="独立功能实现"></a>独立功能实现</h3><p>发布和订阅，事务，Lua脚本，排序实现，二进制位数组，慢查询日志，监视器等。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://note.huangz.me/storage/redis_code_analysis/index.html" target="_blank" rel="external">黄建宏：Redis源码分析</a><br><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="external">github：Redis 3.0 源码注释</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我手上这本&lt;a href=&quot;http://redisbook.com/&quot;&gt;Redis设计与实现&lt;/a&gt;是基于Redis 3.0的开发版，主要包括四个大的部分：&lt;code&gt;数据结构与对象&lt;/code&gt;，&lt;code&gt;单机数据库的实现&lt;/code&gt;，&lt;code&gt;多机数据库的实现&lt;/code&gt;，&lt;code&gt;独立功能的实现&lt;/code&gt;。在阅读这本书的时候，另外参考了作者&lt;br&gt;黄建宏的&lt;a href=&quot;http://note.huangz.me/storage/redis_code_analysis/index.html&quot;&gt;Redis源码分析&lt;/a&gt;和&lt;a href=&quot;https://github.com/huangz1990/redis-3.0-annotated&quot;&gt;github&lt;/a&gt;，感谢。&lt;br&gt;
    
    </summary>
    
      <category term="Redis设计与实现笔记" scheme="https://yezizp2012.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="https://yezizp2012.github.io/tags/redis/"/>
    
      <category term="笔记" scheme="https://yezizp2012.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="源码" scheme="https://yezizp2012.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="引言" scheme="https://yezizp2012.github.io/tags/%E5%BC%95%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://yezizp2012.github.io/2017/01/03/hello%20world/"/>
    <id>https://yezizp2012.github.io/2017/01/03/hello world/</id>
    <published>2017-01-03T08:31:18.000Z</published>
    <updated>2017-01-03T08:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a><center>hello world</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;&lt;center&gt;hello world&lt;/center&gt;&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
